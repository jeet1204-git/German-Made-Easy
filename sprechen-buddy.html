<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprechen Buddy - German Made Easy</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Outfit', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .container { max-width: 900px; width: 100%; }
        .card { background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { font-size: 36px; font-weight: 900; background: linear-gradient(135deg, #FF6B35, #004E89); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 10px; }
        .header p { color: #666; font-size: 18px; }
        .state { display: none; }
        .state.active { display: block; }
        .waiting-animation { text-align: center; padding: 60px 20px; }
        .spinner { width: 80px; height: 80px; border: 8px solid #f3f3f3; border-top: 8px solid #FF6B35; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 30px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .waiting-text { font-size: 24px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .waiting-subtext { color: #666; font-size: 16px; margin-bottom: 30px; }
        .queue-info { background: #FFF3ED; border: 2px solid #FF6B35; border-radius: 16px; padding: 20px; margin-bottom: 20px; }
        .queue-info p { font-size: 15px; color: #1A1A2E; line-height: 1.6; margin-bottom: 8px; }
        .match-found { text-align: center; padding: 40px 20px; }
        .match-emoji { font-size: 80px; margin-bottom: 20px; }
        .match-text { font-size: 28px; font-weight: 700; color: #1A1A2E; margin-bottom: 10px; }
        .partner-info { background: #f8f8f8; border-radius: 16px; padding: 20px; margin: 30px 0; }
        .partner-info h3 { font-size: 18px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .info-row { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e0e0e0; }
        .info-row:last-child { border-bottom: none; }
        .info-label { color: #666; font-weight: 600; }
        .info-value { color: #1A1A2E; font-weight: 700; }
        .task-card { background: linear-gradient(135deg, #FFF3ED, #FFE8DC); border: 3px solid #FF6B35; border-radius: 20px; padding: 30px; margin-bottom: 30px; }
        .task-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .task-type { background: #FF6B35; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 700; }
        .task-level { font-size: 24px; font-weight: 900; color: #FF6B35; }
        .task-scenario { margin-bottom: 20px; }
        .scenario-label { font-size: 12px; text-transform: uppercase; font-weight: 700; color: #666; margin-bottom: 8px; }
        .scenario-text { font-size: 18px; color: #1A1A2E; line-height: 1.6; margin-bottom: 10px; }
        .scenario-gujarati { font-size: 16px; color: #666; font-style: italic; }
        .task-questions { background: white; border-radius: 12px; padding: 20px; }
        .task-questions h4 { font-size: 16px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .task-questions ul { list-style: none; }
        .task-questions li { padding: 10px 0; border-bottom: 1px solid #f0f0f0; color: #1A1A2E; }
        .task-questions li:last-child { border-bottom: none; }
        .timer-section { text-align: center; margin: 30px 0; }
        .timer-display { font-size: 72px; font-weight: 900; color: #FF6B35; margin-bottom: 10px; font-variant-numeric: tabular-nums; }
        .timer-display.warning { color: #f59e0b; animation: pulse 1s infinite; }
        .timer-display.danger { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .timer-label { font-size: 16px; color: #666; font-weight: 600; }
        .video-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; }
        .video-container { position: relative; background: #1A1A2E; border-radius: 16px; overflow: hidden; aspect-ratio: 4/3; }
        .video-container video { width: 100%; height: 100%; object-fit: cover; }
        .video-label { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.7); color: white; padding: 6px 12px; border-radius: 8px; font-size: 14px; font-weight: 600; }
        .connection-status { position: absolute; top: 12px; right: 12px; display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.7); color: white; padding: 6px 12px; border-radius: 8px; font-size: 12px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #10b981; animation: blink 2s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        .btn { padding: 14px 32px; border: none; border-radius: 12px; font-family: 'Outfit', sans-serif; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, #FF6B35, #004E89); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255,107,53,0.4); }
        .btn-secondary { background: white; color: #FF6B35; border: 2px solid #FF6B35; }
        .btn-secondary:hover { background: #FFF3ED; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .evaluation-form { background: #f8f8f8; border-radius: 16px; padding: 30px; margin-bottom: 20px; }
        .evaluation-form h3 { font-size: 20px; font-weight: 700; color: #1A1A2E; margin-bottom: 20px; text-align: center; }
        .criteria-item { background: white; border-radius: 12px; padding: 20px; margin-bottom: 15px; }
        .criteria-label { font-size: 16px; font-weight: 600; color: #1A1A2E; margin-bottom: 12px; }
        .rating-buttons { display: flex; gap: 10px; }
        .rating-btn { flex: 1; padding: 12px; border: 2px solid #e0e0e0; background: white; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.2s; }
        .rating-btn:hover { border-color: #FF6B35; background: #FFF3ED; }
        .rating-btn.selected { border-color: #FF6B35; background: #FF6B35; color: white; }
        .results-section { text-align: center; padding: 40px 20px; }
        .results-emoji { font-size: 80px; margin-bottom: 20px; }
        .results-title { font-size: 28px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .points-earned { background: linear-gradient(135deg, #FFF3ED, #FFE8DC); border: 3px solid #FF6B35; border-radius: 20px; padding: 30px; margin: 30px 0; }
        .points-number { font-size: 48px; font-weight: 900; color: #FF6B35; margin-bottom: 10px; }
        .points-label { font-size: 18px; color: #666; }
        .feedback-section { background: #f8f8f8; border-radius: 16px; padding: 25px; margin: 20px 0; text-align: left; }
        .feedback-section h4 { font-size: 18px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .feedback-item { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e0e0e0; }
        .feedback-item:last-child { border-bottom: none; }
        .feedback-label { color: #666; font-weight: 600; }
        .feedback-score { font-weight: 700; color: #FF6B35; }
        @media (max-width: 768px) { .card { padding: 25px; } .header h1 { font-size: 28px; } .video-section { grid-template-columns: 1fr; } .timer-display { font-size: 56px; } .controls { flex-direction: column; } .btn { width: 100%; justify-content: center; } .rating-buttons { flex-direction: column; } }
        .btn-change-task { padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 14px; font-family: 'Outfit', sans-serif; font-weight: 700; cursor: pointer; }
        .btn-change-task:hover { background: #059669; }
        .btn-add-time { padding: 12px 24px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 14px; font-family: 'Outfit', sans-serif; font-weight: 700; cursor: pointer; }
        .btn-add-time:hover { background: #d97706; }
        .btn-add-time:disabled { background: #9ca3af; cursor: not-allowed; opacity: 0.5; }
        .reconnecting-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 9999; }
        .reconnecting-overlay.active { display: flex; }
        .reconnecting-card { background: white; border-radius: 20px; padding: 40px; text-align: center; max-width: 400px; }
        .reconnecting-card h3 { font-size: 24px; color: #1A1A2E; margin-bottom: 15px; }
        .reconnecting-card p { color: #666; margin-bottom: 20px; }
        .camera-error-box { background: #FFF3ED; border: 2px solid #FF6B35; border-radius: 16px; padding: 20px; margin-bottom: 25px; text-align: left; }
        .camera-error-box p { font-weight: 700; color: #1A1A2E; margin-bottom: 10px; }
        .camera-error-box ol { margin-left: 20px; color: #444; line-height: 1.8; }
        .camera-error-icon { font-size: 64px; margin-bottom: 20px; }
        .camera-error-title { font-size: 24px; font-weight: 700; color: #1A1A2E; margin-bottom: 12px; }
        .camera-error-msg { color: #666; margin-bottom: 20px; line-height: 1.6; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #1A1A2E; color: white; padding: 12px 24px; border-radius: 12px; font-family: 'Outfit', sans-serif; font-weight: 600; z-index: 10000; animation: fadeUp 0.3s ease; pointer-events: none; }
        @keyframes fadeUp { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        button, a { touch-action: manipulation; }
        .ai-fab { position: fixed; bottom: 28px; right: 28px; background: linear-gradient(135deg, #FFD23F, #FF6B35); color: #1A1A2E; padding: 14px 22px; border-radius: 50px; font-weight: 800; font-size: 15px; font-family: 'Outfit', sans-serif; display: none; align-items: center; gap: 10px; box-shadow: 0 8px 30px rgba(255,107,53,0.35); text-decoration: none; z-index: 9998; transition: transform 0.25s, box-shadow 0.25s; white-space: nowrap; }
        .ai-fab.visible { display: flex; }
        .ai-fab:hover { transform: translateY(-3px); box-shadow: 0 14px 40px rgba(255,107,53,0.5); color: #1A1A2E; }
        @media (max-width: 768px) { .ai-fab { bottom: 20px; right: 16px; padding: 12px 16px; font-size: 13px; } .ai-fab .fab-text { display: none; } }

        /* ‚îÄ‚îÄ NEW: permission checking state styles ‚îÄ‚îÄ */
        .perm-checking { text-align: center; padding: 20px 0; color: #666; font-size: 15px; margin-bottom: 15px; }
        .perm-checking .spinner { width: 32px; height: 32px; border-width: 4px; margin: 0 auto 10px; }
    </style>
    <link rel="stylesheet" href="dark-mode.css">
</head>
<body>
<div class="container">
    <div class="card">
        <div class="header">
            <h1>üó£Ô∏è Sprechen Buddy</h1>
            <p>Practice speaking German with real students</p>
        </div>

        <div id="cameraErrorState" class="state">
            <div style="text-align:center;padding:40px 20px;">
                <div class="camera-error-icon" id="cameraErrorIcon">üì∑</div>
                <div class="camera-error-title" id="cameraErrorTitle">Camera Access Needed</div>
                <p class="camera-error-msg" id="cameraErrorMsg">Sprechen Buddy needs your camera and microphone to connect with your practice partner.</p>
                <div class="camera-error-box">
                    <p>How to fix:</p>
                    <ol id="cameraErrorSteps">
                        <li>Click the camera/lock icon in your browser's address bar</li>
                        <li>Set Camera and Microphone to <strong>Allow</strong></li>
                        <li>Click <strong>Retry</strong> below</li>
                    </ol>
                </div>
                <!-- Retry spinner shown while checking -->
                <div class="perm-checking" id="retryChecking" style="display:none;">
                    <div class="spinner"></div>
                    Checking camera access...
                </div>
                <div class="controls" id="cameraErrorControls">
                    <button class="btn btn-primary" onclick="retryCameraAccess()">üîÑ Retry</button>
                    <button class="btn btn-secondary" onclick="window.location.href='dashboard.html'">‚Üê Back to Dashboard</button>
                </div>
            </div>
        </div>

        <div id="waitingState" class="state active">
            <div class="waiting-animation">
                <div class="spinner"></div>
                <div class="waiting-text">Finding your practice partner...</div>
                <div class="waiting-subtext">This usually takes 30-60 seconds</div>
                <div class="queue-info">
                    <p>üë• <strong><span id="queueCount">0</span> students</strong> are waiting to practice</p>
                    <p>üî• You'll be matched with the next available student</p>
                    <p>‚è±Ô∏è Average wait time: <strong>45 seconds</strong></p>
                </div>
                <button class="btn btn-danger" onclick="cancelMatching()">Cancel</button>
            </div>
        </div>

        <div id="matchFoundState" class="state">
            <div class="match-found">
                <div class="match-emoji">üéâ</div>
                <div class="match-text">Match Found!</div>
                <p id="matchStatusText" style="color:#666;margin-bottom:30px;">Connecting you with your practice partner...</p>
                <div class="partner-info">
                    <h3>Your Partner</h3>
                    <div class="info-row"><span class="info-label">Name</span><span class="info-value" id="partnerName">Loading...</span></div>
                    <div class="info-row"><span class="info-label">Level</span><span class="info-value" id="partnerLevel">A2</span></div>
                    <div class="info-row"><span class="info-label">Streak</span><span class="info-value">üî• <span id="partnerStreak">7</span> days</span></div>
                </div>
            </div>
        </div>

        <div id="sessionState" class="state">
            <div class="task-card">
                <div class="task-header">
                    <div class="task-type" id="taskType">Planning Together</div>
                    <div class="task-level" id="taskLevel">A2</div>
                </div>
                <div class="task-scenario">
                    <div class="scenario-label">SCENARIO / ‡™™‡™∞‡™ø‡™∏‡´ç‡™•‡™ø‡™§‡™ø</div>
                    <div class="scenario-text" id="scenarioGerman"></div>
                    <div class="scenario-gujarati" id="scenarioGujarati"></div>
                </div>
                <div class="task-questions">
                    <h4>Diskutieren Sie √ºber:</h4>
                    <ul id="questionsList"></ul>
                </div>
            </div>
            <div class="timer-section">
                <div class="timer-display" id="timerDisplay">20:00</div>
                <div class="timer-label">Time Remaining</div>
            </div>
            <div class="video-section">
                <div class="video-container">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-label">You</div>
                    <div class="connection-status"><div class="status-dot"></div><span>Local</span></div>
                </div>
                <div class="video-container">
                    <video id="remoteVideo" autoplay playsinline></video>
                    <div class="video-label" id="remoteLabel">Partner</div>
                    <div class="connection-status" id="remoteConnectionStatus">
                        <div class="status-dot" id="remoteStatusDot" style="background:#f59e0b;"></div>
                        <span id="remoteStatusText">Connecting...</span>
                    </div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-secondary" id="toggleAudio" onclick="toggleAudio()">üé§ Mute</button>
                <button class="btn btn-secondary" id="toggleVideo" onclick="toggleVideo()">üìπ Stop Video</button>
                <button class="btn-change-task" onclick="changeTask()">üîÑ Change Task</button>
                <button class="btn-add-time" id="btnAddTime" onclick="addExtraTime()">‚è∞ +10 Minutes</button>
                <button class="btn btn-danger" onclick="endSession()">‚ùå End Session</button>
            </div>
            <div class="reconnecting-overlay" id="reconnectingOverlay">
                <div class="reconnecting-card">
                    <div class="spinner"></div>
                    <h3>Partner Left</h3>
                    <p id="reconnectingMessage">Finding new partner...</p>
                </div>
            </div>
            <p style="text-align:center;color:#999;font-size:14px;margin-top:20px;">üí° Speak naturally! Your partner is also learning. Help each other!</p>
        </div>

        <div id="evaluationState" class="state">
            <div class="evaluation-form">
                <h3>Evaluate Your Partner üìä</h3>
                <p style="text-align:center;color:#666;margin-bottom:30px;">Rate your partner (1 = needs work, 5 = excellent)</p>
                <div class="criteria-item">
                    <div class="criteria-label">üó£Ô∏è Fluency (‡™ï‡´á‡™ü‡™≤‡´Ä ‡™∞‡™µ‡™æ‡™®‡´Ä ‡™∞‡´Ä‡™§‡´á ‡™¨‡´ã‡™≤‡´ç‡™Ø‡™æ?)</div>
                    <div class="rating-buttons" data-criteria="fluency">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">üìö Vocabulary (‡™∂‡™¨‡´ç‡™¶‡™≠‡™Ç‡™°‡´ã‡™≥)</div>
                    <div class="rating-buttons" data-criteria="vocabulary">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">‚úÖ Grammar (‡™µ‡´ç‡™Ø‡™æ‡™ï‡™∞‡™£)</div>
                    <div class="rating-buttons" data-criteria="grammar">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">üéØ Task Completion (‡™ï‡´á‡™ü‡™≤‡´Å‡™Ç ‡™∏‡™æ‡™∞‡´Å‡™Ç ‡™™‡´Ç‡™∞‡´ç‡™£ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç?)</div>
                    <div class="rating-buttons" data-criteria="taskCompletion">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-primary" id="submitEvaluation" onclick="submitEvaluation()" disabled>Submit Evaluation ‚úÖ</button>
            </div>
        </div>

        <div id="resultsState" class="state">
            <div class="results-section">
                <div class="results-emoji">üéâ</div>
                <div class="results-title">Great Practice Session!</div>
                <p style="color:#666;margin-bottom:30px;">You both completed the speaking task successfully</p>
                <div class="points-earned"><div class="points-number">+50</div><div class="points-label">Points Earned</div></div>
                <div class="feedback-section">
                    <h4>Your Partner's Evaluation</h4>
                    <div class="feedback-item"><span class="feedback-label">Fluency</span><span class="feedback-score"><span id="resultFluency">4</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Vocabulary</span><span class="feedback-score"><span id="resultVocabulary">4</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Grammar</span><span class="feedback-score"><span id="resultGrammar">3</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Task Completion</span><span class="feedback-score"><span id="resultTaskCompletion">5</span>/5</span></div>
                </div>
                <div class="controls">
                    <button class="btn btn-primary" onclick="practiceAgain()">üîÑ Practice Again</button>
                    <button class="btn btn-secondary" onclick="backToDashboard()">üè† Back to Dashboard</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, onSnapshot, deleteDoc, collection, query, where, getDocs, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

const firebaseConfig = {
    apiKey: "AIzaSyDx2fBrlxNP_zs0xra8ccXyCHQtnHud30E",
    authDomain: "german-made-easy.firebaseapp.com",
    projectId: "german-made-easy",
    storageBucket: "german-made-easy.firebasestorage.app",
    messagingSenderId: "259276936055",
    appId: "1:259276936055:web:5c9b4916734d0271100772",
    measurementId: "G-B7JMB0G85L"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

let currentUser = null, userData = null, matchId = null, matchHandled = false;
let partnerDisplayName = 'Partner', peerConnection = null, localStream = null, remoteStream = null;
let sessionTimer = null, sessionDuration = 1200, timeRemaining = 1200, timerPaused = false;
let timeExtensionUsed = false, currentTask = null, partnerId = null;
let evaluationScores = { fluency: 0, vocabulary: 0, grammar: 0, taskCompletion: 0 };

// ‚îÄ‚îÄ Track whether the camera error was hit during initial load or during a session ‚îÄ‚îÄ
let cameraErrorContext = 'init'; // 'init' | 'session'

const rtcConfig = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
    ],
    iceCandidatePoolSize: 10
};

const tasks = {
    A1: [
        { type: "Introduction", scenario_german: "Sie treffen zum ersten Mal Ihren Sprachpartner.", scenario_gujarati: "‡™§‡™Æ‡´á ‡™™‡´ç‡™∞‡™•‡™Æ ‡™µ‡™ñ‡™§ ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™≠‡™æ‡™∑‡™æ ‡™™‡™æ‡™∞‡´ç‡™ü‡™®‡™∞‡™®‡´á ‡™Æ‡™≥‡´ã ‡™õ‡´ã.", questions: ["Wie hei√üen Sie?","Woher kommen Sie?","Was machen Sie?","Was sind Ihre Hobbys?"] },
        { type: "Shopping", scenario_german: "Sie sind im Supermarkt und brauchen Hilfe.", scenario_gujarati: "‡™§‡™Æ‡´á ‡™∏‡´Å‡™™‡™∞‡™Æ‡™æ‡™∞‡´ç‡™ï‡´á‡™ü‡™Æ‡™æ‡™Ç ‡™õ‡´ã ‡™Ö‡™®‡´á ‡™Æ‡™¶‡™¶‡™®‡´Ä ‡™ú‡™∞‡´Ç‡™∞ ‡™õ‡´á.", questions: ["Was m√∂chten Sie kaufen?","Wo finden Sie das?","Wie viel kostet das?","Zahlen Sie bar oder mit Karte?"] }
    ],
    A2: [
        { type: "Planning Together", scenario_german: "Sie m√∂chten mit Ihrem Partner am Wochenende einen Ausflug machen.", scenario_gujarati: "‡™§‡™Æ‡´á ‡™Ö‡™®‡´á ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™™‡™æ‡™∞‡´ç‡™ü‡™®‡™∞ ‡™∏‡™™‡´ç‡™§‡™æ‡™π‡™æ‡™Ç‡™§‡™Æ‡™æ‡™Ç ‡™è‡™ï ‡™™‡™∞‡´ç‡™Ø‡™ü‡™® ‡™ï‡™∞‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã.", questions: ["Wohin m√∂chten Sie fahren?","Wann sollen Sie fahren?","Was m√∂chten Sie dort machen?","Wie lange m√∂chten Sie bleiben?"] },
        { type: "Restaurant", scenario_german: "Sie gehen zusammen in ein Restaurant essen.", scenario_gujarati: "‡™§‡™Æ‡´á ‡™∏‡™æ‡™•‡´á ‡™è‡™ï ‡™∞‡´á‡™∏‡´ç‡™ü‡´ã‡™∞‡™®‡´ç‡™ü‡™Æ‡™æ‡™Ç ‡™ú‡™Æ‡™µ‡™æ ‡™ú‡™æ‡™ì ‡™õ‡´ã.", questions: ["Welches Restaurant m√∂chten Sie besuchen?","Was m√∂chten Sie essen?","Wann m√∂chten Sie reservieren?","Wie teilen Sie die Rechnung?"] }
    ]
};

function getUserDisplayName() { return userData.name || currentUser.displayName || currentUser.email.split('@')[0]; }

// ‚îÄ‚îÄ IMPROVED: showCameraError now records context so retry knows where to go back ‚îÄ‚îÄ
function showCameraError(title, msg, steps, context = 'init') {
    cameraErrorContext = context;
    document.getElementById('cameraErrorIcon').textContent = 'üì∑';
    document.getElementById('cameraErrorTitle').textContent = title;
    document.getElementById('cameraErrorMsg').textContent = msg;
    if (steps) {
        document.getElementById('cameraErrorSteps').innerHTML = steps.map(s => '<li>' + s + '</li>').join('');
    }
    document.getElementById('retryChecking').style.display = 'none';
    document.getElementById('cameraErrorControls').style.display = 'flex';
    showState('cameraErrorState');
}

// ‚îÄ‚îÄ FIXED retryCameraAccess: uses Permissions API to pre-check, then attempts getUserMedia ‚îÄ‚îÄ
// On Mac, even with browser permission toggled on, the OS may still block it.
// We try getUserMedia directly (most reliable test) with a clear loading state.
window.retryCameraAccess = async function() {
    // Show checking UI
    document.getElementById('retryChecking').style.display = 'block';
    document.getElementById('cameraErrorControls').style.display = 'none';

    // ‚îÄ‚îÄ Step 1: Use Permissions API if available to get a hint ‚îÄ‚îÄ
    let camPermState = 'prompt', micPermState = 'prompt';
    try {
        const [camPerm, micPerm] = await Promise.all([
            navigator.permissions.query({ name: 'camera' }),
            navigator.permissions.query({ name: 'microphone' })
        ]);
        camPermState = camPerm.state;
        micPermState = micPerm.state;
        console.log('Permissions API ‚Üí camera:', camPermState, 'mic:', micPermState);
    } catch(e) {
        // Permissions API not supported (older browsers) ‚Äî just proceed
        console.warn('Permissions API not available, proceeding to getUserMedia');
    }

    // If Permissions API says 'denied', we know the browser (or OS) is blocking it.
    // We can still try getUserMedia ‚Äî if it was the browser toggle, it may now work.
    // If both say 'granted' but we're still on the error screen, it's almost certainly
    // a macOS System Preferences block (Brave not listed / not allowed in Privacy & Security).
    if (camPermState === 'granted' && micPermState === 'granted') {
        // Browser says granted ‚Äî macOS System Preferences is the likely culprit
        // Update the instructions to guide the user to System Preferences
        document.getElementById('cameraErrorIcon').textContent = 'üçé';
        document.getElementById('cameraErrorTitle').textContent = 'macOS Camera Permission Needed';
        document.getElementById('cameraErrorMsg').textContent = 'Your browser has permission, but macOS is blocking camera access for Brave. Fix it in System Settings:';
        document.getElementById('cameraErrorSteps').innerHTML = [
            'Open <strong>System Settings</strong> (Apple menu ‚Üí System Settings)',
            'Go to <strong>Privacy & Security ‚Üí Camera</strong>',
            'Enable the toggle next to <strong>Brave</strong> (or your browser)',
            'Go to <strong>Privacy & Security ‚Üí Microphone</strong> and do the same',
            'Quit and reopen Brave, then click <strong>Retry</strong>'
        ].map(s => '<li>' + s + '</li>').join('');
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';
        // Still attempt getUserMedia in case the user already fixed it
    }

    // ‚îÄ‚îÄ Step 2: Actually try to get the stream ‚îÄ‚îÄ
    try {
        // Stop any existing tracks first to release the device
        if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }

        // Try with ideal constraints, fall back to basic
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 } },
                audio: { echoCancellation: true, noiseSuppression: true }
            });
        } catch(constraintErr) {
            if (['NotAllowedError','PermissionDeniedError','NotFoundError','DevicesNotFoundError','NotReadableError','TrackStartError'].includes(constraintErr.name)) {
                throw constraintErr;
            }
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        }

        // ‚îÄ‚îÄ SUCCESS ‚îÄ‚îÄ
        console.log('‚úÖ Camera access granted on retry');
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';

        // Route back to the correct state
        if (cameraErrorContext === 'session' && matchId) {
            // Was in a session ‚Äî go back and set up WebRTC with existing stream
            showState('sessionState');
            const lv = document.getElementById('localVideo');
            lv.srcObject = localStream;
            lv.play().catch(() => {});
            await setupWebRTC(true); // true = stream already acquired
        } else {
            // Was on initial load ‚Äî restart matching flow
            showState('waitingState');
            await startMatching();
        }

    } catch(error) {
        console.error('Retry camera error:', error.name, error.message);
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';

        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            if (camPermState === 'granted') {
                // Browser says granted but OS blocked it ‚Äî confirm macOS message
                document.getElementById('cameraErrorIcon').textContent = 'üçé';
                document.getElementById('cameraErrorTitle').textContent = 'macOS is Blocking Camera Access';
                document.getElementById('cameraErrorMsg').textContent = 'Your browser permissions look fine, but macOS System Settings is blocking camera/microphone access for this browser.';
                document.getElementById('cameraErrorSteps').innerHTML = [
                    'Open <strong>System Settings</strong> ‚Üí <strong>Privacy & Security</strong> ‚Üí <strong>Camera</strong>',
                    'Enable the toggle next to <strong>Brave</strong> (or your browser name)',
                    'Do the same under <strong>Privacy & Security</strong> ‚Üí <strong>Microphone</strong>',
                    'Quit and reopen your browser, then come back and click <strong>Retry</strong>'
                ].map(s => '<li>' + s + '</li>').join('');
            } else {
                document.getElementById('cameraErrorIcon').textContent = 'üö´';
                document.getElementById('cameraErrorTitle').textContent = 'Camera Access Denied';
                document.getElementById('cameraErrorMsg').textContent = 'Camera/microphone access is still blocked. Please allow it and try again.';
                document.getElementById('cameraErrorSteps').innerHTML = [
                    'Click the camera or lock icon in your browser\'s address bar',
                    'Set Camera and Microphone to <strong>Allow</strong>',
                    'Click <strong>Retry</strong> below'
                ].map(s => '<li>' + s + '</li>').join('');
            }
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            document.getElementById('cameraErrorIcon').textContent = 'üîå';
            document.getElementById('cameraErrorTitle').textContent = 'No Camera Found';
            document.getElementById('cameraErrorMsg').textContent = 'No camera or microphone was detected. Please connect a device and try again.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            document.getElementById('cameraErrorIcon').textContent = '‚ö†Ô∏è';
            document.getElementById('cameraErrorTitle').textContent = 'Camera In Use';
            document.getElementById('cameraErrorMsg').textContent = 'Your camera or microphone is being used by another app. Close it and try again.';
        }
    }
};

function getRandomTask(level) { const t = tasks[level] || tasks.A1; return t[Math.floor(Math.random() * t.length)]; }
function showState(s) { document.querySelectorAll('.state').forEach(el => el.classList.remove('active')); document.getElementById(s).classList.add('active'); }
function showToast(msg) {
    const t = document.createElement('div'); t.className = 'toast'; t.textContent = msg;
    document.body.appendChild(t); setTimeout(() => t.remove(), 3000);
}

onAuthStateChanged(auth, async (user) => {
    if (!user) { window.location.href = 'login.html'; return; }
    currentUser = user;
    const userDoc = await getDoc(doc(db, 'users', user.uid));
    userData = userDoc.data();
    if (userData?.isPaidStudent) document.getElementById('aiFab')?.classList.add('visible');
    startMatching();
});

let queueHeartbeat = null;
function startQueueHeartbeat() {
    if (queueHeartbeat) clearInterval(queueHeartbeat);
    queueHeartbeat = setInterval(async () => {
        if (currentUser && matchId === null) {
            try {
                const ref = doc(db, 'match_queue', currentUser.uid);
                const d = await getDoc(ref);
                if (d.exists()) await updateDoc(ref, { lastSeen: serverTimestamp() });
                else clearInterval(queueHeartbeat);
            } catch(e) {}
        }
    }, 10000);
}
function stopQueueHeartbeat() { if (queueHeartbeat) { clearInterval(queueHeartbeat); queueHeartbeat = null; } }

async function startMatching() {
    showState('waitingState');
    matchHandled = false;

    try { await deleteDoc(doc(db, 'match_queue', currentUser.uid)); } catch(e) {}

    try {
        const staleSnap = await getDocs(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)));
        const cleanups = [];
        staleSnap.forEach(d => {
            if (d.data().status !== 'completed' && d.data().status !== 'cancelled') {
                cleanups.push(updateDoc(doc(db, 'matches', d.id), { status: 'completed' }));
            }
        });
        if (cleanups.length) await Promise.all(cleanups);
    } catch(e) {}

    const preExistingMatchIds = new Set();
    try {
        const snap = await getDocs(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)));
        snap.forEach(d => preExistingMatchIds.add(d.id));
    } catch(e) {}

    const queueRef = doc(db, 'match_queue', currentUser.uid);
    await setDoc(queueRef, {
        userId: currentUser.uid,
        level: userData.level || 'A1',
        streak: userData.streakDays || 1,
        displayName: getUserDisplayName(),
        timestamp: serverTimestamp(),
        lastSeen: serverTimestamp(),
        status: 'waiting'
    });
    startQueueHeartbeat();
    updateQueueCount();

    let unsubQueue = null, unsubMatches = null;

    unsubQueue = onSnapshot(queueRef, async (snapshot) => {
        const data = snapshot.data();
        if (data?.matchId && !matchHandled) {
            if (preExistingMatchIds.has(data.matchId)) return;
            matchHandled = true; matchId = data.matchId;
            stopQueueHeartbeat();
            if (unsubQueue) unsubQueue();
            if (unsubMatches) unsubMatches();
            await handleMatchFound();
        }
    });

    unsubMatches = onSnapshot(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)), async (snapshot) => {
        for (const change of snapshot.docChanges()) {
            if (change.type === 'added') {
                const docId = change.doc.id;
                if (preExistingMatchIds.has(docId)) continue;
                const data = change.doc.data();
                if (data.status === 'active' && !matchHandled) {
                    matchHandled = true; matchId = docId;
                    stopQueueHeartbeat();
                    try { await updateDoc(queueRef, { matchId: docId, status: 'matched' }); } catch(e) {}
                    if (unsubQueue) unsubQueue();
                    if (unsubMatches) unsubMatches();
                    await handleMatchFound();
                }
            }
        }
    });

    window.addEventListener('beforeunload', () => { if (unsubQueue) unsubQueue(); if (unsubMatches) unsubMatches(); });
    setTimeout(() => findMatch(), 2000);
}

async function findMatch() {
    if (matchId || matchHandled) return;
    try {
        const snapshot = await getDocs(query(collection(db, 'match_queue'), where('status', '==', 'waiting')));
        const candidates = [];
        snapshot.forEach(d => {
            if (d.id !== currentUser.uid) {
                const data = d.data();
                const lastSeen = data.lastSeen?.toMillis() || data.timestamp?.toMillis() || 0;
                if (Date.now() - lastSeen < 30000) candidates.push({ id: d.id, ...data });
                else deleteDoc(doc(db, 'match_queue', d.id)).catch(() => {});
            }
        });

        if (candidates.length > 0 && !matchId && !matchHandled) {
            const partner = candidates[0];
            const newMatchId = `match_${Date.now()}_${currentUser.uid.substring(0,6)}`;
            await setDoc(doc(db, 'matches', newMatchId), {
                users: [currentUser.uid, partner.id],
                userNames: { [currentUser.uid]: getUserDisplayName(), [partner.id]: partner.displayName || 'Student' },
                level: userData.level || 'A1',
                task: getRandomTask(userData.level || 'A1'),
                startTime: serverTimestamp(),
                status: 'active'
            });
            await updateDoc(doc(db, 'match_queue', currentUser.uid), { matchId: newMatchId, status: 'matched' });
            try { await updateDoc(doc(db, 'match_queue', partner.id), { matchId: newMatchId, status: 'matched' }); } catch(e) {}
        } else if (!matchId && !matchHandled) {
            setTimeout(() => findMatch(), 3000);
        }
    } catch(e) {
        if (!matchId && !matchHandled) setTimeout(() => findMatch(), 3000);
    }
}

async function updateQueueCount() {
    const s = await getDocs(query(collection(db, 'match_queue'), where('status', '==', 'waiting')));
    document.getElementById('queueCount').textContent = s.size;
}

async function handleMatchFound() {
    showState('matchFoundState');
    document.getElementById('matchStatusText').textContent = 'Connecting to your partner...';

    const matchSnap = await getDoc(doc(db, 'matches', matchId));
    const matchData = matchSnap.data();
    partnerId = matchData.users.find(id => id !== currentUser.uid);
    partnerDisplayName = matchData.userNames?.[partnerId] || 'Student';
    let partnerLevel = matchData.level || 'A1', partnerStreak = 1;

    try {
        const pq = await getDoc(doc(db, 'match_queue', partnerId));
        if (pq.exists()) {
            const pd = pq.data();
            if (pd.displayName) partnerDisplayName = pd.displayName;
            if (pd.level) partnerLevel = pd.level;
            if (pd.streak) partnerStreak = pd.streak;
        }
    } catch(e) {}

    document.getElementById('partnerName').textContent = partnerDisplayName;
    document.getElementById('partnerLevel').textContent = partnerLevel;
    document.getElementById('partnerStreak').textContent = partnerStreak;
    document.getElementById('matchStatusText').textContent = 'Match found! Starting session...';
    setTimeout(() => startSession(matchData), 2000);
}

async function startSession(matchData) {
    showState('sessionState');
    currentTask = matchData.task;
    displayTask(currentTask);
    document.getElementById('taskLevel').textContent = userData.level || 'A1';

    onSnapshot(doc(db, 'matches', matchId), (snap) => {
        const data = snap.data();
        if (data?.task && data?.taskChangedAt && JSON.stringify(data.task) !== JSON.stringify(currentTask)) {
            currentTask = data.task; displayTask(data.task); showToast('üîÑ Partner changed task');
        }
        if (data?.timeExtended && !timeExtensionUsed) {
            timeExtensionUsed = true; timeRemaining += 600; sessionDuration += 600;
            document.getElementById('btnAddTime').disabled = true;
            document.getElementById('btnAddTime').textContent = '‚è∞ Time Added';
            showToast('‚è∞ Partner added 10 minutes');
        }
    });

    startTimer();
    await setupWebRTC(false);
}

function displayTask(task) {
    document.getElementById('taskType').textContent = task.type;
    document.getElementById('scenarioGerman').textContent = task.scenario_german;
    document.getElementById('scenarioGujarati').textContent = task.scenario_gujarati;
    const list = document.getElementById('questionsList');
    list.innerHTML = '';
    task.questions.forEach(q => { const li = document.createElement('li'); li.textContent = q; list.appendChild(li); });
}

function startTimer() {
    timeRemaining = sessionDuration; timerPaused = false;
    if (sessionTimer) clearInterval(sessionTimer);
    const display = document.getElementById('timerDisplay');
    sessionTimer = setInterval(() => {
        if (timerPaused) return;
        timeRemaining--;
        const m = Math.floor(timeRemaining / 60), s = timeRemaining % 60;
        display.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        display.classList.remove('warning','danger');
        if (timeRemaining <= 60) display.classList.add('danger');
        else if (timeRemaining <= 120) display.classList.add('warning');
        if (timeRemaining === 0) { clearInterval(sessionTimer); endSession(); }
    }, 1000);
}

function updateRemoteStatus(state) {
    const dot = document.getElementById('remoteStatusDot'), text = document.getElementById('remoteStatusText');
    if (!dot || !text) return;
    const map = { connected: ['#10b981','Connected'], completed: ['#10b981','Connected'], checking: ['#f59e0b','Connecting...'], new: ['#f59e0b','Connecting...'], disconnected: ['#f59e0b','Reconnecting...'], failed: ['#ef4444','Failed'], closed: ['#6b7280','Closed'] };
    const [color, label] = map[state] || ['#f59e0b','Connecting...'];
    dot.style.background = color; text.textContent = label;
}

// ‚îÄ‚îÄ FIXED setupWebRTC: accepts `streamAlreadyAcquired` flag so retry doesn't re-request camera ‚îÄ‚îÄ
async function setupWebRTC(streamAlreadyAcquired = false) {
    // Step 1: Acquire media (skip if already acquired by retryCameraAccess)
    if (!streamAlreadyAcquired || !localStream) {
        try {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: { echoCancellation: true, noiseSuppression: true }
                });
            } catch(constraintError) {
                if (['NotAllowedError','PermissionDeniedError','NotFoundError','DevicesNotFoundError','NotReadableError','TrackStartError'].includes(constraintError.name)) {
                    throw constraintError;
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
        } catch(error) {
            console.error('Media access error:', error.name, error.message);
            cameraErrorContext = matchId ? 'session' : 'init';

            // ‚îÄ‚îÄ Check Permissions API to give smarter error message ‚îÄ‚îÄ
            let camState = 'unknown';
            try { camState = (await navigator.permissions.query({ name: 'camera' })).state; } catch(e) {}

            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                if (camState === 'granted') {
                    // Browser says granted ‚Üí macOS System Preferences is blocking
                    showCameraError(
                        'üçé macOS is Blocking Camera Access',
                        'Your browser permissions look fine, but macOS System Settings is blocking camera/microphone access for Brave.',
                        [
                            'Open <strong>System Settings</strong> ‚Üí <strong>Privacy & Security</strong> ‚Üí <strong>Camera</strong>',
                            'Enable the toggle next to <strong>Brave</strong>',
                            'Do the same under <strong>Microphone</strong>',
                            'Quit and reopen Brave, then click <strong>Retry</strong>'
                        ],
                        cameraErrorContext
                    );
                } else {
                    showCameraError(
                        'üö´ Camera Access Denied',
                        'You blocked camera/microphone access. Please allow it in your browser settings, then click Retry.',
                        [
                            'Click the camera or lock icon in your browser\'s address bar',
                            'Set Camera and Microphone to <strong>Allow</strong>',
                            'Click <strong>Retry</strong> below'
                        ],
                        cameraErrorContext
                    );
                }
            } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                showCameraError('üîå No Camera Found', 'No camera or microphone was detected. Please connect a device and try again.',
                    ['Connect a webcam or headset with microphone', 'Click <strong>Retry</strong> below'], cameraErrorContext);
            } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                showCameraError('‚ö†Ô∏è Camera In Use', 'Your camera or microphone is being used by another app. Close it and try again.',
                    ['Close other apps using your camera (e.g. Zoom, Teams, other browser tabs)', 'Click <strong>Retry</strong> below'], cameraErrorContext);
            } else {
                showCameraError('üì∑ Camera Error', 'Could not start camera/microphone: ' + error.message,
                    ['Check that your camera and microphone are connected', 'Try refreshing the page', 'Click <strong>Retry</strong> below'], cameraErrorContext);
            }
            return;
        }
    }

    // Step 2: WebRTC peer connection setup
    try {
        const lv = document.getElementById('localVideo'); lv.srcObject = localStream; lv.play().catch(() => {});

        peerConnection = new RTCPeerConnection(rtcConfig);
        localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));

        const rv = document.getElementById('remoteVideo');
        peerConnection.ontrack = (e) => {
            if (e.streams?.[0]) { rv.srcObject = e.streams[0]; remoteStream = e.streams[0]; }
            else { if (!remoteStream) { remoteStream = new MediaStream(); rv.srcObject = remoteStream; } remoteStream.addTrack(e.track); }
            rv.play().catch(() => { document.addEventListener('click', function p() { rv.play().catch(()=>{}); document.removeEventListener('click',p); }, {once:true}); });
        };

        peerConnection.onicecandidate = async (e) => {
            if (e.candidate) { try { await addDoc(collection(db,'matches',matchId,'candidates_'+currentUser.uid), e.candidate.toJSON()); } catch(err) {} }
        };

        peerConnection.oniceconnectionstatechange = () => {
            const s = peerConnection.iceConnectionState; updateRemoteStatus(s);
            if (s === 'disconnected') setTimeout(() => { if (peerConnection?.iceConnectionState === 'disconnected') handlePartnerDisconnection(); }, 3000);
            if (s === 'failed') handlePartnerDisconnection();
        };
        peerConnection.onconnectionstatechange = () => {
            const s = peerConnection.connectionState;
            if (s === 'connected') { updateRemoteStatus('connected'); if (rv.srcObject) rv.play().catch(()=>{}); }
            if (s === 'failed' || s === 'closed') handlePartnerDisconnection();
        };

        let iceCandidateBuffer = [], isRemoteDescSet = false;
        async function flushBuffer() {
            isRemoteDescSet = true;
            for (const c of iceCandidateBuffer) { try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {} }
            iceCandidateBuffer = [];
        }

        const connTimeout = setTimeout(() => {
            if (peerConnection && !['connected','completed'].includes(peerConnection.iceConnectionState)) {
                showToast('Connection timeout ‚Äî retrying...');
                handlePartnerDisconnection();
            }
        }, 30000);
        peerConnection.addEventListener('iceconnectionstatechange', () => {
            if (['connected','completed'].includes(peerConnection.iceConnectionState)) clearTimeout(connTimeout);
        });

        const matchSnap = await getDoc(doc(db,'matches',matchId));
        const users = matchSnap.data().users;
        partnerId = users.find(id => id !== currentUser.uid);
        document.getElementById('remoteLabel').textContent = partnerDisplayName || 'Partner';

        onSnapshot(query(collection(db,'matches',matchId,'candidates_'+partnerId)), (snap) => {
            snap.docChanges().forEach(async (change) => {
                if (change.type === 'added') {
                    const c = change.doc.data();
                    if (isRemoteDescSet) { try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {} }
                    else iceCandidateBuffer.push(c);
                }
            });
        });

        if (users[0] === currentUser.uid) {
            const offer = await peerConnection.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
            await peerConnection.setLocalDescription(offer);
            await updateDoc(doc(db,'matches',matchId), { offer: {type:offer.type, sdp:offer.sdp} });
            const unsub = onSnapshot(doc(db,'matches',matchId), async (snap) => {
                const d = snap.data();
                if (d?.answer && !peerConnection.remoteDescription) {
                    try { await peerConnection.setRemoteDescription(new RTCSessionDescription(d.answer)); await flushBuffer(); unsub(); } catch(e) {}
                }
            });
        } else {
            const unsub = onSnapshot(doc(db,'matches',matchId), async (snap) => {
                const d = snap.data();
                if (d?.offer && !peerConnection.remoteDescription) {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(d.offer));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        await updateDoc(doc(db,'matches',matchId), { answer: {type:answer.type, sdp:answer.sdp} });
                        await flushBuffer(); unsub();
                    } catch(e) {}
                }
            });
        }
    } catch(error) {
        console.error('WebRTC setup error:', error);
        showToast('Connection setup failed. Please try again.');
    }
}

let disconnectionHandled = false;
async function handlePartnerDisconnection() {
    if (disconnectionHandled) return;
    disconnectionHandled = true;
    try {
        timerPaused = true;
        document.getElementById('reconnectingOverlay').classList.add('active');
        document.getElementById('reconnectingMessage').textContent = 'Partner left. Finding new partner...';
        if (peerConnection) { peerConnection.close(); peerConnection = null; }
        if (remoteStream) { remoteStream.getTracks().forEach(t=>t.stop()); remoteStream = null; document.getElementById('remoteVideo').srcObject = null; }
        if (matchId) { try { await updateDoc(doc(db,'matches',matchId), {status:'completed'}); } catch(e) {} }

        matchId = null; matchHandled = false; partnerId = null;

        const seenIds = new Set();
        const q = query(collection(db,'matches'), where('users','array-contains',currentUser.uid));
        (await getDocs(q)).forEach(d => seenIds.add(d.id));

        const queueRef = doc(db,'match_queue',currentUser.uid);
        await setDoc(queueRef, { userId:currentUser.uid, level:userData.level||'A1', streak:userData.streakDays||1, displayName:getUserDisplayName(), timestamp:serverTimestamp(), lastSeen:serverTimestamp(), status:'waiting' });
        startQueueHeartbeat();

        let unsubM;
        const unsubQ = onSnapshot(queueRef, async (snap) => {
            const d = snap.data();
            if (d?.matchId && d?.status==='matched' && !matchHandled && !seenIds.has(d.matchId)) {
                matchHandled = true; matchId = d.matchId;
                stopQueueHeartbeat(); unsubQ(); if (unsubM) unsubM();
                document.getElementById('reconnectingOverlay').classList.remove('active');
                disconnectionHandled = false;
                await handleMatchFound();
            }
        });
        unsubM = onSnapshot(q, async (snap) => {
            for (const change of snap.docChanges()) {
                if (change.type==='added' && !seenIds.has(change.doc.id)) {
                    seenIds.add(change.doc.id);
                    const d = change.doc.data();
                    if (d.status==='active' && !matchHandled) {
                        matchHandled = true; matchId = change.doc.id;
                        stopQueueHeartbeat(); unsubQ(); unsubM();
                        try { await updateDoc(queueRef, {matchId:matchId,status:'matched'}); } catch(e) {}
                        document.getElementById('reconnectingOverlay').classList.remove('active');
                        disconnectionHandled = false;
                        await handleMatchFound();
                    }
                }
            }
        });
        setTimeout(() => findMatch(), 1000);
    } catch(e) {
        console.error('Disconnection error:', e);
        setTimeout(() => { document.getElementById('reconnectingOverlay').classList.remove('active'); endSession(); }, 2000);
    }
}

window.toggleAudio = () => { if (localStream) { const t=localStream.getAudioTracks()[0]; t.enabled=!t.enabled; document.getElementById('toggleAudio').textContent=t.enabled?'üé§ Mute':'üîá Unmute'; } };
window.toggleVideo = () => { if (localStream) { const t=localStream.getVideoTracks()[0]; t.enabled=!t.enabled; document.getElementById('toggleVideo').textContent=t.enabled?'üìπ Stop Video':'üìπ Start Video'; } };
window.changeTask = async () => {
    if (!matchId || !userData) return;
    const newTask = getRandomTask(userData.level||'A1'); currentTask = newTask;
    await updateDoc(doc(db,'matches',matchId), {task:newTask, taskChangedAt:serverTimestamp()});
    displayTask(newTask); showToast('‚úÖ Task changed: ' + newTask.type);
};
window.addExtraTime = () => {
    if (timeExtensionUsed) { showToast('‚è∞ Time already added'); return; }
    timeRemaining+=600; sessionDuration+=600; timeExtensionUsed=true;
    document.getElementById('btnAddTime').disabled=true;
    document.getElementById('btnAddTime').textContent='‚è∞ Time Added';
    showToast('‚úÖ Added 10 minutes!');
    if (matchId) updateDoc(doc(db,'matches',matchId), {timeExtended:true, extendedAt:serverTimestamp()}).catch(()=>{});
};
window.endSession = () => {
    if (sessionTimer) clearInterval(sessionTimer);
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
    if (peerConnection) peerConnection.close();
    if (matchId) updateDoc(doc(db,'matches',matchId), {status:'completed'}).catch(()=>{});
    showState('evaluationState');
    setupEvaluationListeners();
};

function setupEvaluationListeners() {
    document.querySelectorAll('.rating-buttons').forEach(container => {
        const criteria = container.dataset.criteria;
        container.querySelectorAll('.rating-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                container.querySelectorAll('.rating-btn').forEach(b=>b.classList.remove('selected'));
                btn.classList.add('selected');
                evaluationScores[criteria] = parseInt(btn.dataset.value);
                document.getElementById('submitEvaluation').disabled = !Object.values(evaluationScores).every(s=>s>0);
            });
        });
    });
}

window.submitEvaluation = async () => {
    await updateDoc(doc(db,'matches',matchId), { [`evaluations.${currentUser.uid}`]:evaluationScores, [`completed.${currentUser.uid}`]:true, status:'completed' });
    await updateDoc(doc(db,'users',currentUser.uid), { totalScore:(userData.totalScore||0)+50, weeklyScore:(userData.weeklyScore||0)+50, sessionsCompleted:(userData.sessionsCompleted||0)+1 });
    await deleteDoc(doc(db,'match_queue',currentUser.uid));
    document.getElementById('resultFluency').textContent = Math.floor(Math.random()*2)+4;
    document.getElementById('resultVocabulary').textContent = Math.floor(Math.random()*2)+3;
    document.getElementById('resultGrammar').textContent = Math.floor(Math.random()*2)+3;
    document.getElementById('resultTaskCompletion').textContent = Math.floor(Math.random()*2)+4;
    showState('resultsState');
};
window.cancelMatching = async () => {
    stopQueueHeartbeat();
    if (matchId) { try { await updateDoc(doc(db,'matches',matchId),{status:'cancelled'}); } catch(e) {} }
    await deleteDoc(doc(db,'match_queue',currentUser.uid));
    window.location.href = 'dashboard.html';
};
window.practiceAgain = () => { evaluationScores={fluency:0,vocabulary:0,grammar:0,taskCompletion:0}; matchId=null; matchHandled=false; partnerDisplayName='Partner'; location.reload(); };
window.backToDashboard = () => { window.location.href='dashboard.html'; };

window.addEventListener('beforeunload', async () => {
    stopQueueHeartbeat();
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
    if (peerConnection) peerConnection.close();
    if (currentUser) {
        try {
            await deleteDoc(doc(db,'match_queue',currentUser.uid));
            if (matchId) await updateDoc(doc(db,'matches',matchId), {[`disconnected.${currentUser.uid}`]:true, status:'completed'});
        } catch(e) {}
    }
});
</script>
<a href="ai-partner.html" class="ai-fab" id="aiFab">ü§ñ <span class="fab-text">AI Practice</span></a>
</body>
</html>
