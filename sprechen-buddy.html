<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprechen Buddy - German Made Easy</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Outfit', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .container { max-width: 900px; width: 100%; }
        .card { background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { font-size: 36px; font-weight: 900; background: linear-gradient(135deg, #FF6B35, #004E89); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 10px; }
        .header p { color: #666; font-size: 18px; }
        .state { display: none; }
        .state.active { display: block; }
        .waiting-animation { text-align: center; padding: 60px 20px; }
        .spinner { width: 80px; height: 80px; border: 8px solid #f3f3f3; border-top: 8px solid #FF6B35; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 30px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .waiting-text { font-size: 24px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .waiting-subtext { color: #666; font-size: 16px; margin-bottom: 30px; }
        .queue-info { background: #FFF3ED; border: 2px solid #FF6B35; border-radius: 16px; padding: 20px; margin-bottom: 20px; }
        .queue-info p { font-size: 15px; color: #1A1A2E; line-height: 1.6; margin-bottom: 8px; }
        .match-found { text-align: center; padding: 40px 20px; }
        .match-emoji { font-size: 80px; margin-bottom: 20px; }
        .match-text { font-size: 28px; font-weight: 700; color: #1A1A2E; margin-bottom: 10px; }
        .partner-info { background: #f8f8f8; border-radius: 16px; padding: 20px; margin: 30px 0; }
        .partner-info h3 { font-size: 18px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .info-row { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e0e0e0; }
        .info-row:last-child { border-bottom: none; }
        .info-label { color: #666; font-weight: 600; }
        .info-value { color: #1A1A2E; font-weight: 700; }
        .task-card { background: linear-gradient(135deg, #FFF3ED, #FFE8DC); border: 3px solid #FF6B35; border-radius: 20px; padding: 30px; margin-bottom: 30px; }
        .task-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .task-type { background: #FF6B35; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 700; }
        .task-level { font-size: 24px; font-weight: 900; color: #FF6B35; }
        .task-scenario { margin-bottom: 20px; }
        .scenario-label { font-size: 12px; text-transform: uppercase; font-weight: 700; color: #666; margin-bottom: 8px; }
        .scenario-text { font-size: 18px; color: #1A1A2E; line-height: 1.6; margin-bottom: 10px; }
        .scenario-gujarati { font-size: 16px; color: #666; font-style: italic; }
        .task-questions { background: white; border-radius: 12px; padding: 20px; }
        .task-questions h4 { font-size: 16px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .task-questions ul { list-style: none; }
        .task-questions li { padding: 10px 0; border-bottom: 1px solid #f0f0f0; color: #1A1A2E; }
        .task-questions li:last-child { border-bottom: none; }
        .timer-section { text-align: center; margin: 30px 0; }
        .timer-display { font-size: 72px; font-weight: 900; color: #FF6B35; margin-bottom: 10px; font-variant-numeric: tabular-nums; }
        .timer-display.warning { color: #f59e0b; animation: pulse 1s infinite; }
        .timer-display.danger { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .timer-label { font-size: 16px; color: #666; font-weight: 600; }
        .video-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; }
        .video-container { position: relative; background: #1A1A2E; border-radius: 16px; overflow: hidden; aspect-ratio: 4/3; }
        .video-container video { width: 100%; height: 100%; object-fit: cover; }
        .video-label { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.7); color: white; padding: 6px 12px; border-radius: 8px; font-size: 14px; font-weight: 600; }
        .connection-status { position: absolute; top: 12px; right: 12px; display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.7); color: white; padding: 6px 12px; border-radius: 8px; font-size: 12px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #10b981; animation: blink 2s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        .btn { padding: 14px 32px; border: none; border-radius: 12px; font-family: 'Outfit', sans-serif; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, #FF6B35, #004E89); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255,107,53,0.4); }
        .btn-secondary { background: white; color: #FF6B35; border: 2px solid #FF6B35; }
        .btn-secondary:hover { background: #FFF3ED; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .evaluation-form { background: #f8f8f8; border-radius: 16px; padding: 30px; margin-bottom: 20px; }
        .evaluation-form h3 { font-size: 20px; font-weight: 700; color: #1A1A2E; margin-bottom: 20px; text-align: center; }
        .criteria-item { background: white; border-radius: 12px; padding: 20px; margin-bottom: 15px; }
        .criteria-label { font-size: 16px; font-weight: 600; color: #1A1A2E; margin-bottom: 12px; }
        .rating-buttons { display: flex; gap: 10px; }
        .rating-btn { flex: 1; padding: 12px; border: 2px solid #e0e0e0; background: white; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.2s; }
        .rating-btn:hover { border-color: #FF6B35; background: #FFF3ED; }
        .rating-btn.selected { border-color: #FF6B35; background: #FF6B35; color: white; }
        .results-section { text-align: center; padding: 40px 20px; }
        .results-emoji { font-size: 80px; margin-bottom: 20px; }
        .results-title { font-size: 28px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .points-earned { background: linear-gradient(135deg, #FFF3ED, #FFE8DC); border: 3px solid #FF6B35; border-radius: 20px; padding: 30px; margin: 30px 0; }
        .points-number { font-size: 48px; font-weight: 900; color: #FF6B35; margin-bottom: 10px; }
        .points-label { font-size: 18px; color: #666; }
        .feedback-section { background: #f8f8f8; border-radius: 16px; padding: 25px; margin: 20px 0; text-align: left; }
        .feedback-section h4 { font-size: 18px; font-weight: 700; color: #1A1A2E; margin-bottom: 15px; }
        .feedback-item { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e0e0e0; }
        .feedback-item:last-child { border-bottom: none; }
        .feedback-label { color: #666; font-weight: 600; }
        .feedback-score { font-weight: 700; color: #FF6B35; }
        @media (max-width: 768px) { .card { padding: 25px; } .header h1 { font-size: 28px; } .video-section { grid-template-columns: 1fr; } .timer-display { font-size: 56px; } .controls { flex-direction: column; } .btn { width: 100%; justify-content: center; } .rating-buttons { flex-direction: column; } }
        .btn-change-task { padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 14px; font-family: 'Outfit', sans-serif; font-weight: 700; cursor: pointer; }
        .btn-change-task:hover { background: #059669; }
        .btn-add-time { padding: 12px 24px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 14px; font-family: 'Outfit', sans-serif; font-weight: 700; cursor: pointer; }
        .btn-add-time:hover { background: #d97706; }
        .btn-add-time:disabled { background: #9ca3af; cursor: not-allowed; opacity: 0.5; }
        .reconnecting-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 9999; }
        .reconnecting-overlay.active { display: flex; }
        .reconnecting-card { background: white; border-radius: 20px; padding: 40px; text-align: center; max-width: 400px; }
        .reconnecting-card h3 { font-size: 24px; color: #1A1A2E; margin-bottom: 15px; }
        .reconnecting-card p { color: #666; margin-bottom: 20px; }
        .camera-error-box { background: #FFF3ED; border: 2px solid #FF6B35; border-radius: 16px; padding: 20px; margin-bottom: 25px; text-align: left; }
        .camera-error-box p { font-weight: 700; color: #1A1A2E; margin-bottom: 10px; }
        .camera-error-box ol { margin-left: 20px; color: #444; line-height: 1.8; }
        .camera-error-icon { font-size: 64px; margin-bottom: 20px; }
        .camera-error-title { font-size: 24px; font-weight: 700; color: #1A1A2E; margin-bottom: 12px; }
        .camera-error-msg { color: #666; margin-bottom: 20px; line-height: 1.6; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #1A1A2E; color: white; padding: 12px 24px; border-radius: 12px; font-family: 'Outfit', sans-serif; font-weight: 600; z-index: 10000; animation: fadeUp 0.3s ease; pointer-events: none; }
        @keyframes fadeUp { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        button, a { touch-action: manipulation; }
        .ai-fab { position: fixed; bottom: 28px; right: 28px; background: linear-gradient(135deg, #FFD23F, #FF6B35); color: #1A1A2E; padding: 14px 22px; border-radius: 50px; font-weight: 800; font-size: 15px; font-family: 'Outfit', sans-serif; display: none; align-items: center; gap: 10px; box-shadow: 0 8px 30px rgba(255,107,53,0.35); text-decoration: none; z-index: 9998; transition: transform 0.25s, box-shadow 0.25s; white-space: nowrap; }
        .ai-fab.visible { display: flex; }
        .ai-fab:hover { transform: translateY(-3px); box-shadow: 0 14px 40px rgba(255,107,53,0.5); color: #1A1A2E; }
        @media (max-width: 768px) { .ai-fab { bottom: 20px; right: 16px; padding: 12px 16px; font-size: 13px; } .ai-fab .fab-text { display: none; } }

        /* â”€â”€ NEW: permission checking state styles â”€â”€ */
        .perm-checking { text-align: center; padding: 20px 0; color: #666; font-size: 15px; margin-bottom: 15px; }
        .perm-checking .spinner { width: 32px; height: 32px; border-width: 4px; margin: 0 auto 10px; }
    </style>
    <link rel="stylesheet" href="dark-mode.css">
</head>
<body>
<div class="container">
    <div class="card">
        <div class="header">
            <h1>ğŸ—£ï¸ Sprechen Buddy</h1>
            <p>Practice speaking German with real students</p>
        </div>

        <div id="cameraErrorState" class="state">
            <div style="text-align:center;padding:40px 20px;">
                <div class="camera-error-icon" id="cameraErrorIcon">ğŸ“·</div>
                <div class="camera-error-title" id="cameraErrorTitle">Camera Access Needed</div>
                <p class="camera-error-msg" id="cameraErrorMsg">Sprechen Buddy needs your camera and microphone to connect with your practice partner.</p>
                <div class="camera-error-box">
                    <p>How to fix:</p>
                    <ol id="cameraErrorSteps">
                        <li>Click the camera/lock icon in your browser's address bar</li>
                        <li>Set Camera and Microphone to <strong>Allow</strong></li>
                        <li>Click <strong>Retry</strong> below</li>
                    </ol>
                </div>
                <!-- Retry spinner shown while checking -->
                <div class="perm-checking" id="retryChecking" style="display:none;">
                    <div class="spinner"></div>
                    Checking camera access...
                </div>
                <div class="controls" id="cameraErrorControls">
                    <button class="btn btn-primary" onclick="retryCameraAccess()">ğŸ”„ Retry</button>
                    <button class="btn btn-secondary" onclick="window.location.href='dashboard.html'">â† Back to Dashboard</button>
                </div>
            </div>
        </div>

        <div id="waitingState" class="state active">
            <div class="waiting-animation">
                <div class="spinner"></div>
                <div class="waiting-text">Finding your practice partner...</div>
                <div class="waiting-subtext">This usually takes 30-60 seconds</div>
                <div class="queue-info">
                    <p>ğŸ‘¥ <strong><span id="queueCount">0</span> students</strong> are waiting to practice</p>
                    <p>ğŸ”¥ You'll be matched with the next available student</p>
                    <p>â±ï¸ Average wait time: <strong>45 seconds</strong></p>
                </div>
                <button class="btn btn-danger" onclick="cancelMatching()">Cancel</button>
            </div>
        </div>

        <div id="matchFoundState" class="state">
            <div class="match-found">
                <div class="match-emoji">ğŸ‰</div>
                <div class="match-text">Match Found!</div>
                <p id="matchStatusText" style="color:#666;margin-bottom:30px;">Connecting you with your practice partner...</p>
                <div class="partner-info">
                    <h3>Your Partner</h3>
                    <div class="info-row"><span class="info-label">Name</span><span class="info-value" id="partnerName">Loading...</span></div>
                    <div class="info-row"><span class="info-label">Level</span><span class="info-value" id="partnerLevel">A2</span></div>
                    <div class="info-row"><span class="info-label">Streak</span><span class="info-value">ğŸ”¥ <span id="partnerStreak">7</span> days</span></div>
                </div>
            </div>
        </div>

        <div id="sessionState" class="state">
            <div class="task-card">
                <div class="task-header">
                    <div class="task-type" id="taskType">Planning Together</div>
                    <div class="task-level" id="taskLevel">A2</div>
                </div>
                <div class="task-scenario">
                    <div class="scenario-label">SCENARIO / àªªàª°àª¿àª¸à«àª¥àª¿àª¤àª¿</div>
                    <div class="scenario-text" id="scenarioGerman"></div>
                    <div class="scenario-gujarati" id="scenarioGujarati"></div>
                </div>
                <div class="task-questions">
                    <h4>Diskutieren Sie Ã¼ber:</h4>
                    <ul id="questionsList"></ul>
                </div>
            </div>
            <div class="timer-section">
                <div class="timer-display" id="timerDisplay">20:00</div>
                <div class="timer-label">Time Remaining</div>
            </div>
            <div class="video-section">
                <div class="video-container">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-label">You</div>
                    <div class="connection-status"><div class="status-dot"></div><span>Local</span></div>
                </div>
                <div class="video-container">
                    <video id="remoteVideo" autoplay playsinline></video>
                    <div class="video-label" id="remoteLabel">Partner</div>
                    <div class="connection-status" id="remoteConnectionStatus">
                        <div class="status-dot" id="remoteStatusDot" style="background:#f59e0b;"></div>
                        <span id="remoteStatusText">Connecting...</span>
                    </div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-secondary" id="toggleAudio" onclick="toggleAudio()">ğŸ¤ Mute</button>
                <button class="btn btn-secondary" id="toggleVideo" onclick="toggleVideo()">ğŸ“¹ Stop Video</button>
                <button class="btn-change-task" onclick="changeTask()">ğŸ”„ Change Task</button>
                <button class="btn-add-time" id="btnAddTime" onclick="addExtraTime()">â° +10 Minutes</button>
                <button class="btn btn-danger" onclick="endSession()">âŒ End Session</button>
            </div>
            <div class="reconnecting-overlay" id="reconnectingOverlay">
                <div class="reconnecting-card">
                    <div class="spinner"></div>
                    <h3>Partner Left</h3>
                    <p id="reconnectingMessage">Finding new partner...</p>
                </div>
            </div>
            <p style="text-align:center;color:#999;font-size:14px;margin-top:20px;">ğŸ’¡ Speak naturally! Your partner is also learning. Help each other!</p>
        </div>

        <div id="evaluationState" class="state">
            <div class="evaluation-form">
                <h3>Evaluate Your Partner ğŸ“Š</h3>
                <p style="text-align:center;color:#666;margin-bottom:30px;">Rate your partner (1 = needs work, 5 = excellent)</p>
                <div class="criteria-item">
                    <div class="criteria-label">ğŸ—£ï¸ Fluency (àª•à«‡àªŸàª²à«€ àª°àªµàª¾àª¨à«€ àª°à«€àª¤à«‡ àª¬à«‹àª²à«àª¯àª¾?)</div>
                    <div class="rating-buttons" data-criteria="fluency">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">ğŸ“š Vocabulary (àª¶àª¬à«àª¦àª­àª‚àª¡à«‹àª³)</div>
                    <div class="rating-buttons" data-criteria="vocabulary">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">âœ… Grammar (àªµà«àª¯àª¾àª•àª°àª£)</div>
                    <div class="rating-buttons" data-criteria="grammar">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
                <div class="criteria-item">
                    <div class="criteria-label">ğŸ¯ Task Completion (àª•à«‡àªŸàª²à«àª‚ àª¸àª¾àª°à«àª‚ àªªà«‚àª°à«àª£ àª•àª°à«àª¯à«àª‚?)</div>
                    <div class="rating-buttons" data-criteria="taskCompletion">
                        <button class="rating-btn" data-value="1">1</button><button class="rating-btn" data-value="2">2</button><button class="rating-btn" data-value="3">3</button><button class="rating-btn" data-value="4">4</button><button class="rating-btn" data-value="5">5</button>
                    </div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-primary" id="submitEvaluation" onclick="submitEvaluation()" disabled>Submit Evaluation âœ…</button>
            </div>
        </div>

        <div id="resultsState" class="state">
            <div class="results-section">
                <div class="results-emoji">ğŸ‰</div>
                <div class="results-title">Great Practice Session!</div>
                <p style="color:#666;margin-bottom:30px;">You both completed the speaking task successfully</p>
                <div class="points-earned"><div class="points-number">+50</div><div class="points-label">Points Earned</div></div>
                <div class="feedback-section">
                    <h4>Your Partner's Evaluation</h4>
                    <div class="feedback-item"><span class="feedback-label">Fluency</span><span class="feedback-score"><span id="resultFluency">4</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Vocabulary</span><span class="feedback-score"><span id="resultVocabulary">4</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Grammar</span><span class="feedback-score"><span id="resultGrammar">3</span>/5</span></div>
                    <div class="feedback-item"><span class="feedback-label">Task Completion</span><span class="feedback-score"><span id="resultTaskCompletion">5</span>/5</span></div>
                </div>
                <div class="controls">
                    <button class="btn btn-primary" onclick="practiceAgain()">ğŸ”„ Practice Again</button>
                    <button class="btn btn-secondary" onclick="backToDashboard()">ğŸ  Back to Dashboard</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, onSnapshot, deleteDoc, collection, query, where, getDocs, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

const firebaseConfig = {
    apiKey: "AIzaSyDx2fBrlxNP_zs0xra8ccXyCHQtnHud30E",
    authDomain: "german-made-easy.firebaseapp.com",
    projectId: "german-made-easy",
    storageBucket: "german-made-easy.firebasestorage.app",
    messagingSenderId: "259276936055",
    appId: "1:259276936055:web:5c9b4916734d0271100772",
    measurementId: "G-B7JMB0G85L"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

let currentUser = null, userData = null, matchId = null, matchHandled = false;
let partnerDisplayName = 'Partner', peerConnection = null, localStream = null, remoteStream = null;
let sessionTimer = null, sessionDuration = 1200, timeRemaining = 1200, timerPaused = false;
let timeExtensionUsed = false, currentTask = null, partnerId = null;
let evaluationScores = { fluency: 0, vocabulary: 0, grammar: 0, taskCompletion: 0 };

// â”€â”€ Track whether the camera error was hit during initial load or during a session â”€â”€
let cameraErrorContext = 'init'; // 'init' | 'session'

const rtcConfig = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
    ],
    iceCandidatePoolSize: 10
};

const tasks = {
    A1: [
        { type: "Introduction", scenario_german: "Sie treffen zum ersten Mal Ihren Sprachpartner.", scenario_gujarati: "àª¤àª®à«‡ àªªà«àª°àª¥àª® àªµàª–àª¤ àª¤àª®àª¾àª°àª¾ àª­àª¾àª·àª¾ àªªàª¾àª°à«àªŸàª¨àª°àª¨à«‡ àª®àª³à«‹ àª›à«‹.", questions: ["Wie heiÃŸen Sie?","Woher kommen Sie?","Was machen Sie?","Was sind Ihre Hobbys?"] },
        { type: "Shopping", scenario_german: "Sie sind im Supermarkt und brauchen Hilfe.", scenario_gujarati: "àª¤àª®à«‡ àª¸à«àªªàª°àª®àª¾àª°à«àª•à«‡àªŸàª®àª¾àª‚ àª›à«‹ àª…àª¨à«‡ àª®àª¦àª¦àª¨à«€ àªœàª°à«‚àª° àª›à«‡.", questions: ["Was mÃ¶chten Sie kaufen?","Wo finden Sie das?","Wie viel kostet das?","Zahlen Sie bar oder mit Karte?"] }
    ],
    A2: [
        { type: "Planning Together", scenario_german: "Sie mÃ¶chten mit Ihrem Partner am Wochenende einen Ausflug machen.", scenario_gujarati: "àª¤àª®à«‡ àª…àª¨à«‡ àª¤àª®àª¾àª°àª¾ àªªàª¾àª°à«àªŸàª¨àª° àª¸àªªà«àª¤àª¾àª¹àª¾àª‚àª¤àª®àª¾àª‚ àªàª• àªªàª°à«àª¯àªŸàª¨ àª•àª°àªµàª¾ àª®àª¾àª‚àª—à«‹ àª›à«‹.", questions: ["Wohin mÃ¶chten Sie fahren?","Wann sollen Sie fahren?","Was mÃ¶chten Sie dort machen?","Wie lange mÃ¶chten Sie bleiben?"] },
        { type: "Restaurant", scenario_german: "Sie gehen zusammen in ein Restaurant essen.", scenario_gujarati: "àª¤àª®à«‡ àª¸àª¾àª¥à«‡ àªàª• àª°à«‡àª¸à«àªŸà«‹àª°àª¨à«àªŸàª®àª¾àª‚ àªœàª®àªµàª¾ àªœàª¾àª“ àª›à«‹.", questions: ["Welches Restaurant mÃ¶chten Sie besuchen?","Was mÃ¶chten Sie essen?","Wann mÃ¶chten Sie reservieren?","Wie teilen Sie die Rechnung?"] }
    ]
};

function getUserDisplayName() { return userData.name || currentUser.displayName || currentUser.email.split('@')[0]; }

// â”€â”€ OS / browser detection for smart error messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getOSName() {
    const ua = navigator.userAgent;
    if (/Windows/.test(ua)) return 'windows';
    if (/Mac/.test(ua)) return 'mac';
    if (/Android/.test(ua)) return 'android';
    if (/iPhone|iPad/.test(ua)) return 'ios';
    return 'other';
}
function getBrowserName() {
    const ua = navigator.userAgent;
    if (navigator.brave || /Brave/.test(ua)) return 'Brave';
    if (/Edg\//.test(ua)) return 'Microsoft Edge';
    if (/OPR|Opera/.test(ua)) return 'Opera';
    if (/Chrome/.test(ua)) return 'Chrome';
    if (/Firefox/.test(ua)) return 'Firefox';
    if (/Safari/.test(ua)) return 'Safari';
    return 'your browser';
}

// â”€â”€ Smart camera error steps based on OS + browser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getCameraSteps(errorType) {
    const os = getOSName();
    const browser = getBrowserName();
    if (errorType === 'denied') {
        if (os === 'windows') return [
            `Click the <strong>camera/lock icon</strong> in ${browser}'s address bar â†’ set Camera &amp; Microphone to <strong>Allow</strong>`,
            'Still blocked? Open <strong>Windows Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
            `Make sure <strong>Camera access</strong> and <strong>${browser}</strong> are both toggled <strong>On</strong>`,
            'Reload the page and click <strong>Retry</strong>'
        ];
        if (os === 'mac') return [
            `Click the <strong>camera/lock icon</strong> in ${browser}'s address bar â†’ set to <strong>Allow</strong>`,
            'Still blocked? Open <strong>System Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
            `Enable the toggle next to <strong>${browser}</strong>`,
            `Quit &amp; reopen ${browser}, then click <strong>Retry</strong>`
        ];
        return [
            `Click the camera or lock icon in <strong>${browser}'s</strong> address bar`,
            'Set Camera and Microphone to <strong>Allow</strong>',
            'Click <strong>Retry</strong> below'
        ];
    }
    if (errorType === 'inuse') return [
        'Close <strong>Zoom, Teams, Google Meet</strong> or any other video app',
        'Close other browser tabs that may be using the camera',
        'Click <strong>Retry</strong> below'
    ];
    if (errorType === 'notfound') return [
        'Connect a webcam and microphone (or use a laptop with built-in camera)',
        'Check Device Manager / System Settings to ensure the camera is recognised',
        'Click <strong>Retry</strong> below'
    ];
    return [
        'Make sure camera and microphone are connected and working',
        'Try a different browser (Chrome or Firefox recommended)',
        'Reload the page, then click <strong>Retry</strong>'
    ];
}

// â”€â”€ IMPROVED: showCameraError now records context so retry knows where to go back â”€â”€
function showCameraError(title, msg, steps, context = 'init') {
    cameraErrorContext = context;
    document.getElementById('cameraErrorIcon').textContent = 'ğŸ“·';
    document.getElementById('cameraErrorTitle').textContent = title;
    document.getElementById('cameraErrorMsg').textContent = msg;
    if (steps) {
        document.getElementById('cameraErrorSteps').innerHTML = steps.map(s => '<li>' + s + '</li>').join('');
    }
    document.getElementById('retryChecking').style.display = 'none';
    document.getElementById('cameraErrorControls').style.display = 'flex';
    showState('cameraErrorState');
}

// â”€â”€ FIXED retryCameraAccess: uses Permissions API to pre-check, then attempts getUserMedia â”€â”€
// On Mac, even with browser permission toggled on, the OS may still block it.
// We try getUserMedia directly (most reliable test) with a clear loading state.
window.retryCameraAccess = async function() {
    // Show checking UI
    document.getElementById('retryChecking').style.display = 'block';
    document.getElementById('cameraErrorControls').style.display = 'none';

    // â”€â”€ Step 1: Use Permissions API if available to get a hint â”€â”€
    let camPermState = 'prompt', micPermState = 'prompt';
    try {
        const [camPerm, micPerm] = await Promise.all([
            navigator.permissions.query({ name: 'camera' }),
            navigator.permissions.query({ name: 'microphone' })
        ]);
        camPermState = camPerm.state;
        micPermState = micPerm.state;
        console.log('Permissions API â†’ camera:', camPermState, 'mic:', micPermState);
    } catch(e) {
        // Permissions API not supported (older browsers) â€” just proceed
        console.warn('Permissions API not available, proceeding to getUserMedia');
    }

    // If Permissions API says 'denied', we know the browser (or OS) is blocking it.
    // We can still try getUserMedia â€” if it was the browser toggle, it may now work.
    // If both say 'granted' but we're still on the error screen, it's almost certainly
    // a macOS System Preferences block (Brave not listed / not allowed in Privacy & Security).
    if (camPermState === 'granted' && micPermState === 'granted') {
        // Browser says granted â€” OS-level block (Windows or macOS System Settings)
        const browser = getBrowserName(), os = getOSName();
        const osIcon = os === 'windows' ? 'ğŸªŸ' : 'ğŸ';
        const osName = os === 'windows' ? 'Windows' : 'macOS';
        const osSteps = os === 'windows'
            ? ['Open <strong>Windows Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
               `Make sure <strong>Camera access</strong> and <strong>${browser}</strong> are toggled <strong>On</strong>`,
               `Check <strong>Microphone</strong> the same way`,
               `Reload the page and click <strong>Retry</strong>`]
            : [`Open <strong>System Settings â†’ Privacy &amp; Security â†’ Camera</strong>`,
               `Enable the toggle next to <strong>${browser}</strong>`,
               `Also enable <strong>${browser}</strong> under <strong>Microphone</strong>`,
               `Quit &amp; reopen ${browser}, then click <strong>Retry</strong>`];
        document.getElementById('cameraErrorIcon').textContent = osIcon;
        document.getElementById('cameraErrorTitle').textContent = `${osName} is Blocking Camera Access`;
        document.getElementById('cameraErrorMsg').textContent = `${browser} has permission, but ${osName} System Settings is blocking camera/microphone access.`;
        document.getElementById('cameraErrorSteps').innerHTML = osSteps.map(s => '<li>' + s + '</li>').join('');
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';
        // Still attempt getUserMedia in case the user already fixed it
    }

    // â”€â”€ Step 2: Actually try to get the stream â”€â”€
    try {
        // Stop any existing tracks first to release the device
        if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }

        // Try with ideal constraints, fall back to basic
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 } },
                audio: { echoCancellation: true, noiseSuppression: true }
            });
        } catch(constraintErr) {
            if (['NotAllowedError','PermissionDeniedError','NotFoundError','DevicesNotFoundError','NotReadableError','TrackStartError'].includes(constraintErr.name)) {
                throw constraintErr;
            }
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        }

        // â”€â”€ SUCCESS â”€â”€
        console.log('âœ… Camera access granted on retry');
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';

        // Route back to the correct state
        if (cameraErrorContext === 'session' && matchId) {
            // Was in a session â€” go back and set up WebRTC with existing stream
            showState('sessionState');
            const lv = document.getElementById('localVideo');
            lv.srcObject = localStream;
            lv.play().catch(() => {});
            await setupWebRTC(true); // true = stream already acquired
        } else {
            // Was on initial load â€” restart matching flow
            showState('waitingState');
            await startMatching();
        }

    } catch(error) {
        console.error('Retry camera error:', error.name, error.message);
        document.getElementById('retryChecking').style.display = 'none';
        document.getElementById('cameraErrorControls').style.display = 'flex';

        const browser = getBrowserName(), os = getOSName();
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            if (camPermState === 'granted') {
                const osIcon = os === 'windows' ? 'ğŸªŸ' : 'ğŸ';
                const osName = os === 'windows' ? 'Windows' : 'macOS';
                const osSteps = os === 'windows'
                    ? ['Open <strong>Windows Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
                       `Toggle <strong>Camera access</strong> and <strong>${browser}</strong> to <strong>On</strong>`,
                       `Same for <strong>Microphone</strong>`,
                       `Reload and click <strong>Retry</strong>`]
                    : [`Open <strong>System Settings â†’ Privacy &amp; Security â†’ Camera</strong>`,
                       `Enable <strong>${browser}</strong>, do same for Microphone`,
                       `Quit &amp; reopen ${browser}, then click <strong>Retry</strong>`];
                document.getElementById('cameraErrorIcon').textContent = osIcon;
                document.getElementById('cameraErrorTitle').textContent = `${osName} is Blocking Camera`;
                document.getElementById('cameraErrorMsg').textContent = `${browser} has permission but ${osName} System Settings is blocking camera/microphone access.`;
                document.getElementById('cameraErrorSteps').innerHTML = osSteps.map(s => '<li>' + s + '</li>').join('');
            } else {
                document.getElementById('cameraErrorIcon').textContent = 'ğŸš«';
                document.getElementById('cameraErrorTitle').textContent = 'Camera Access Denied';
                document.getElementById('cameraErrorMsg').textContent = `${browser} needs permission to use your camera and microphone.`;
                document.getElementById('cameraErrorSteps').innerHTML = getCameraSteps('denied').map(s => '<li>' + s + '</li>').join('');
            }
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            document.getElementById('cameraErrorIcon').textContent = 'ğŸ”Œ';
            document.getElementById('cameraErrorTitle').textContent = 'No Camera Found';
            document.getElementById('cameraErrorMsg').textContent = 'No camera or microphone was detected. Please connect a device and try again.';
            document.getElementById('cameraErrorSteps').innerHTML = getCameraSteps('notfound').map(s => '<li>' + s + '</li>').join('');
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            document.getElementById('cameraErrorIcon').textContent = 'âš ï¸';
            document.getElementById('cameraErrorTitle').textContent = 'Camera In Use';
            document.getElementById('cameraErrorMsg').textContent = 'Your camera or microphone is being used by another app. Close it and try again.';
            document.getElementById('cameraErrorSteps').innerHTML = getCameraSteps('inuse').map(s => '<li>' + s + '</li>').join('');
        }
    }
};

function getRandomTask(level) { const t = tasks[level] || tasks.A1; return t[Math.floor(Math.random() * t.length)]; }
function showState(s) { document.querySelectorAll('.state').forEach(el => el.classList.remove('active')); document.getElementById(s).classList.add('active'); }
function showToast(msg) {
    const t = document.createElement('div'); t.className = 'toast'; t.textContent = msg;
    document.body.appendChild(t); setTimeout(() => t.remove(), 3000);
}

onAuthStateChanged(auth, async (user) => {
    if (!user) { window.location.href = 'login.html'; return; }
    currentUser = user;
    const userDoc = await getDoc(doc(db, 'users', user.uid));
    userData = userDoc.data();
    // Show AI FAB for all logged-in users (free trial available to everyone)
    document.getElementById('aiFab')?.classList.add('visible');
    startMatching();
});

let queueHeartbeat = null;
function startQueueHeartbeat() {
    if (queueHeartbeat) clearInterval(queueHeartbeat);
    queueHeartbeat = setInterval(async () => {
        if (currentUser && matchId === null) {
            try {
                const ref = doc(db, 'match_queue', currentUser.uid);
                const d = await getDoc(ref);
                if (d.exists()) await updateDoc(ref, { lastSeen: serverTimestamp() });
                else clearInterval(queueHeartbeat);
            } catch(e) {}
        }
    }, 10000);
}
function stopQueueHeartbeat() { if (queueHeartbeat) { clearInterval(queueHeartbeat); queueHeartbeat = null; } }

async function startMatching() {
    showState('waitingState');
    matchHandled = false;

    // â”€â”€ Request camera permission UPFRONT so user sees the prompt immediately â”€â”€
    // This is the key fix for desktop: on mobile the OS prompt is hard to miss,
    // but on desktop it shows as a small browser dropdown that can be dismissed.
    // By requesting early (in the waiting state), the user grants/denies before matching.
    if (!localStream) {
        try {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: { echoCancellation: true, noiseSuppression: true }
                });
            } catch(constraintErr) {
                if (['NotAllowedError','PermissionDeniedError','NotFoundError','DevicesNotFoundError','NotReadableError','TrackStartError'].includes(constraintErr.name)) {
                    throw constraintErr;
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
        } catch(error) {
            console.error('Early camera request failed:', error.name, error.message);
            cameraErrorContext = 'init';
            let camState = 'unknown';
            try { camState = (await navigator.permissions.query({ name: 'camera' })).state; } catch(e) {}
            const browser = getBrowserName(), os = getOSName();
            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                if (camState === 'granted') {
                    const osIcon = os === 'windows' ? 'ğŸªŸ' : 'ğŸ';
                    const osName = os === 'windows' ? 'Windows' : 'macOS';
                    const osSteps = os === 'windows'
                        ? ['Open <strong>Windows Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
                           `Toggle <strong>Camera access</strong> and <strong>${browser}</strong> to <strong>On</strong>`,
                           `Same for <strong>Microphone</strong>`, `Reload and click <strong>Retry</strong>`]
                        : [`Open <strong>System Settings â†’ Privacy &amp; Security â†’ Camera</strong>`,
                           `Enable <strong>${browser}</strong>`, `Same for Microphone`,
                           `Quit &amp; reopen ${browser}, click <strong>Retry</strong>`];
                    showCameraError(`${osIcon} ${osName} is Blocking Camera`,
                        `${browser} has permission but ${osName} System Settings is blocking camera/microphone access.`,
                        osSteps, 'init');
                } else {
                    showCameraError('ğŸš« Camera Access Denied',
                        `${browser} needs permission to use your camera and microphone.`,
                        getCameraSteps('denied'), 'init');
                }
            } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                showCameraError('ğŸ”Œ No Camera Found', 'No camera or microphone was detected.',
                    getCameraSteps('notfound'), 'init');
            } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                showCameraError('âš ï¸ Camera In Use', 'Your camera is being used by another app. Close it and retry.',
                    getCameraSteps('inuse'), 'init');
            } else {
                showCameraError('ğŸ“· Camera Error', 'Could not access camera: ' + error.message,
                    getCameraSteps('other'), 'init');
            }
            return; // Stop matching â€” user needs to fix camera first
        }
    }

    try { await deleteDoc(doc(db, 'match_queue', currentUser.uid)); } catch(e) {}

    try {
        const staleSnap = await getDocs(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)));
        const cleanups = [];
        staleSnap.forEach(d => {
            if (d.data().status !== 'completed' && d.data().status !== 'cancelled') {
                cleanups.push(updateDoc(doc(db, 'matches', d.id), { status: 'completed' }));
            }
        });
        if (cleanups.length) await Promise.all(cleanups);
    } catch(e) {}

    const preExistingMatchIds = new Set();
    try {
        const snap = await getDocs(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)));
        snap.forEach(d => preExistingMatchIds.add(d.id));
    } catch(e) {}

    const queueRef = doc(db, 'match_queue', currentUser.uid);
    await setDoc(queueRef, {
        userId: currentUser.uid,
        level: userData.level || 'A1',
        streak: userData.streakDays || 1,
        displayName: getUserDisplayName(),
        timestamp: serverTimestamp(),
        lastSeen: serverTimestamp(),
        status: 'waiting'
    });
    startQueueHeartbeat();
    updateQueueCount();

    let unsubQueue = null, unsubMatches = null;

    unsubQueue = onSnapshot(queueRef, async (snapshot) => {
        const data = snapshot.data();
        if (data?.matchId && !matchHandled) {
            if (preExistingMatchIds.has(data.matchId)) return;
            matchHandled = true; matchId = data.matchId;
            stopQueueHeartbeat();
            if (unsubQueue) unsubQueue();
            if (unsubMatches) unsubMatches();
            await handleMatchFound();
        }
    });

    unsubMatches = onSnapshot(query(collection(db, 'matches'), where('users', 'array-contains', currentUser.uid)), async (snapshot) => {
        for (const change of snapshot.docChanges()) {
            if (change.type === 'added') {
                const docId = change.doc.id;
                if (preExistingMatchIds.has(docId)) continue;
                const data = change.doc.data();
                if (data.status === 'active' && !matchHandled) {
                    matchHandled = true; matchId = docId;
                    stopQueueHeartbeat();
                    try { await updateDoc(queueRef, { matchId: docId, status: 'matched' }); } catch(e) {}
                    if (unsubQueue) unsubQueue();
                    if (unsubMatches) unsubMatches();
                    await handleMatchFound();
                }
            }
        }
    });

    window.addEventListener('beforeunload', () => { if (unsubQueue) unsubQueue(); if (unsubMatches) unsubMatches(); });
    setTimeout(() => findMatch(), 2000);
}

async function findMatch() {
    if (matchId || matchHandled) return;
    try {
        const snapshot = await getDocs(query(collection(db, 'match_queue'), where('status', '==', 'waiting')));
        const candidates = [];
        snapshot.forEach(d => {
            if (d.id !== currentUser.uid) {
                const data = d.data();
                const lastSeen = data.lastSeen?.toMillis() || data.timestamp?.toMillis() || 0;
                if (Date.now() - lastSeen < 30000) candidates.push({ id: d.id, ...data });
                else deleteDoc(doc(db, 'match_queue', d.id)).catch(() => {});
            }
        });

        if (candidates.length > 0 && !matchId && !matchHandled) {
            const partner = candidates[0];
            const newMatchId = `match_${Date.now()}_${currentUser.uid.substring(0,6)}`;
            await setDoc(doc(db, 'matches', newMatchId), {
                users: [currentUser.uid, partner.id],
                userNames: { [currentUser.uid]: getUserDisplayName(), [partner.id]: partner.displayName || 'Student' },
                level: userData.level || 'A1',
                task: getRandomTask(userData.level || 'A1'),
                startTime: serverTimestamp(),
                status: 'active'
            });
            await updateDoc(doc(db, 'match_queue', currentUser.uid), { matchId: newMatchId, status: 'matched' });
            try { await updateDoc(doc(db, 'match_queue', partner.id), { matchId: newMatchId, status: 'matched' }); } catch(e) {}
        } else if (!matchId && !matchHandled) {
            setTimeout(() => findMatch(), 3000);
        }
    } catch(e) {
        if (!matchId && !matchHandled) setTimeout(() => findMatch(), 3000);
    }
}

async function updateQueueCount() {
    const s = await getDocs(query(collection(db, 'match_queue'), where('status', '==', 'waiting')));
    document.getElementById('queueCount').textContent = s.size;
}

async function handleMatchFound() {
    showState('matchFoundState');
    document.getElementById('matchStatusText').textContent = 'Connecting to your partner...';

    const matchSnap = await getDoc(doc(db, 'matches', matchId));
    const matchData = matchSnap.data();
    partnerId = matchData.users.find(id => id !== currentUser.uid);
    partnerDisplayName = matchData.userNames?.[partnerId] || 'Student';
    let partnerLevel = matchData.level || 'A1', partnerStreak = 1;

    try {
        const pq = await getDoc(doc(db, 'match_queue', partnerId));
        if (pq.exists()) {
            const pd = pq.data();
            if (pd.displayName) partnerDisplayName = pd.displayName;
            if (pd.level) partnerLevel = pd.level;
            if (pd.streak) partnerStreak = pd.streak;
        }
    } catch(e) {}

    document.getElementById('partnerName').textContent = partnerDisplayName;
    document.getElementById('partnerLevel').textContent = partnerLevel;
    document.getElementById('partnerStreak').textContent = partnerStreak;
    document.getElementById('matchStatusText').textContent = 'Match found! Starting session...';
    setTimeout(() => startSession(matchData), 2000);
}

async function startSession(matchData) {
    showState('sessionState');
    currentTask = matchData.task;
    displayTask(currentTask);
    document.getElementById('taskLevel').textContent = userData.level || 'A1';

    onSnapshot(doc(db, 'matches', matchId), (snap) => {
        const data = snap.data();
        if (data?.task && data?.taskChangedAt && JSON.stringify(data.task) !== JSON.stringify(currentTask)) {
            currentTask = data.task; displayTask(data.task); showToast('ğŸ”„ Partner changed task');
        }
        if (data?.timeExtended && !timeExtensionUsed) {
            timeExtensionUsed = true; timeRemaining += 600; sessionDuration += 600;
            document.getElementById('btnAddTime').disabled = true;
            document.getElementById('btnAddTime').textContent = 'â° Time Added';
            showToast('â° Partner added 10 minutes');
        }
    });

    startTimer();
    await setupWebRTC(false);
}

function displayTask(task) {
    document.getElementById('taskType').textContent = task.type;
    document.getElementById('scenarioGerman').textContent = task.scenario_german;
    document.getElementById('scenarioGujarati').textContent = task.scenario_gujarati;
    const list = document.getElementById('questionsList');
    list.innerHTML = '';
    task.questions.forEach(q => { const li = document.createElement('li'); li.textContent = q; list.appendChild(li); });
}

function startTimer() {
    timeRemaining = sessionDuration; timerPaused = false;
    if (sessionTimer) clearInterval(sessionTimer);
    const display = document.getElementById('timerDisplay');
    sessionTimer = setInterval(() => {
        if (timerPaused) return;
        timeRemaining--;
        const m = Math.floor(timeRemaining / 60), s = timeRemaining % 60;
        display.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        display.classList.remove('warning','danger');
        if (timeRemaining <= 60) display.classList.add('danger');
        else if (timeRemaining <= 120) display.classList.add('warning');
        if (timeRemaining === 0) { clearInterval(sessionTimer); endSession(); }
    }, 1000);
}

function updateRemoteStatus(state) {
    const dot = document.getElementById('remoteStatusDot'), text = document.getElementById('remoteStatusText');
    if (!dot || !text) return;
    const map = { connected: ['#10b981','Connected'], completed: ['#10b981','Connected'], checking: ['#f59e0b','Connecting...'], new: ['#f59e0b','Connecting...'], disconnected: ['#f59e0b','Reconnecting...'], failed: ['#ef4444','Failed'], closed: ['#6b7280','Closed'] };
    const [color, label] = map[state] || ['#f59e0b','Connecting...'];
    dot.style.background = color; text.textContent = label;
}

// â”€â”€ setupWebRTC: skips camera if already acquired by startMatching() or retryCameraAccess() â”€â”€
async function setupWebRTC(streamAlreadyAcquired = false) {
    // Step 1: Acquire media (skip if already acquired â€” reuse stream from startMatching)
    if (!localStream) {
        try {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: { echoCancellation: true, noiseSuppression: true }
                });
            } catch(constraintError) {
                if (['NotAllowedError','PermissionDeniedError','NotFoundError','DevicesNotFoundError','NotReadableError','TrackStartError'].includes(constraintError.name)) {
                    throw constraintError;
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
        } catch(error) {
            console.error('Media access error:', error.name, error.message);
            cameraErrorContext = matchId ? 'session' : 'init';

            // â”€â”€ Check Permissions API to give smarter error message â”€â”€
            let camState = 'unknown';
            try { camState = (await navigator.permissions.query({ name: 'camera' })).state; } catch(e) {}

            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                const browser = getBrowserName(), os = getOSName();
                if (camState === 'granted') {
                    // Browser says granted â†’ OS-level block (Windows or macOS system settings)
                    const osSteps = os === 'windows'
                        ? ['Open <strong>Windows Settings â†’ Privacy &amp; Security â†’ Camera</strong>',
                           `Make sure <strong>Camera access</strong> and <strong>${browser}</strong> are toggled <strong>On</strong>`,
                           `Also check <strong>Microphone</strong> settings the same way`,
                           `Reload the page and click <strong>Retry</strong>`]
                        : [`Open <strong>System Settings â†’ Privacy &amp; Security â†’ Camera</strong>`,
                           `Enable the toggle next to <strong>${browser}</strong>`,
                           `Also enable <strong>${browser}</strong> under <strong>Microphone</strong>`,
                           `Quit &amp; reopen ${browser}, then click <strong>Retry</strong>`];
                    const osIcon = os === 'windows' ? 'ğŸªŸ' : 'ğŸ';
                    const osName = os === 'windows' ? 'Windows' : 'macOS';
                    showCameraError(
                        `${osIcon} ${osName} is Blocking Camera Access`,
                        `${browser} has permission, but ${osName} System Settings is blocking camera/microphone access.`,
                        osSteps, cameraErrorContext
                    );
                } else {
                    showCameraError('ğŸš« Camera Access Denied',
                        `${browser} needs permission to use your camera and microphone.`,
                        getCameraSteps('denied'), cameraErrorContext);
                }
            } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                showCameraError('ğŸ”Œ No Camera Found', 'No camera or microphone was detected. Please connect a device and try again.',
                    getCameraSteps('notfound'), cameraErrorContext);
            } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                showCameraError('âš ï¸ Camera In Use', 'Your camera or microphone is being used by another app. Close it and try again.',
                    getCameraSteps('inuse'), cameraErrorContext);
            } else {
                showCameraError('ğŸ“· Camera Error', 'Could not start camera/microphone: ' + error.message,
                    getCameraSteps('other'), cameraErrorContext);
            }
            return;
        }
    }

    // Step 2: WebRTC peer connection setup
    try {
        const lv = document.getElementById('localVideo'); lv.srcObject = localStream; lv.play().catch(() => {});

        peerConnection = new RTCPeerConnection(rtcConfig);
        localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));

        const rv = document.getElementById('remoteVideo');
        peerConnection.ontrack = (e) => {
            if (e.streams?.[0]) { rv.srcObject = e.streams[0]; remoteStream = e.streams[0]; }
            else { if (!remoteStream) { remoteStream = new MediaStream(); rv.srcObject = remoteStream; } remoteStream.addTrack(e.track); }
            rv.play().catch(() => { document.addEventListener('click', function p() { rv.play().catch(()=>{}); document.removeEventListener('click',p); }, {once:true}); });
        };

        peerConnection.onicecandidate = async (e) => {
            if (e.candidate) { try { await addDoc(collection(db,'matches',matchId,'candidates_'+currentUser.uid), e.candidate.toJSON()); } catch(err) {} }
        };

        peerConnection.oniceconnectionstatechange = () => {
            const s = peerConnection.iceConnectionState; updateRemoteStatus(s);
            if (s === 'disconnected') setTimeout(() => { if (peerConnection?.iceConnectionState === 'disconnected') handlePartnerDisconnection(); }, 3000);
            if (s === 'failed') handlePartnerDisconnection();
        };
        peerConnection.onconnectionstatechange = () => {
            const s = peerConnection.connectionState;
            if (s === 'connected') { updateRemoteStatus('connected'); if (rv.srcObject) rv.play().catch(()=>{}); }
            if (s === 'failed' || s === 'closed') handlePartnerDisconnection();
        };

        let iceCandidateBuffer = [], isRemoteDescSet = false;
        async function flushBuffer() {
            isRemoteDescSet = true;
            for (const c of iceCandidateBuffer) { try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {} }
            iceCandidateBuffer = [];
        }

        const connTimeout = setTimeout(() => {
            if (peerConnection && !['connected','completed'].includes(peerConnection.iceConnectionState)) {
                showToast('Connection timeout â€” retrying...');
                handlePartnerDisconnection();
            }
        }, 30000);
        peerConnection.addEventListener('iceconnectionstatechange', () => {
            if (['connected','completed'].includes(peerConnection.iceConnectionState)) clearTimeout(connTimeout);
        });

        const matchSnap = await getDoc(doc(db,'matches',matchId));
        const users = matchSnap.data().users;
        partnerId = users.find(id => id !== currentUser.uid);
        document.getElementById('remoteLabel').textContent = partnerDisplayName || 'Partner';

        onSnapshot(query(collection(db,'matches',matchId,'candidates_'+partnerId)), (snap) => {
            snap.docChanges().forEach(async (change) => {
                if (change.type === 'added') {
                    const c = change.doc.data();
                    if (isRemoteDescSet) { try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {} }
                    else iceCandidateBuffer.push(c);
                }
            });
        });

        if (users[0] === currentUser.uid) {
            const offer = await peerConnection.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
            await peerConnection.setLocalDescription(offer);
            await updateDoc(doc(db,'matches',matchId), { offer: {type:offer.type, sdp:offer.sdp} });
            const unsub = onSnapshot(doc(db,'matches',matchId), async (snap) => {
                const d = snap.data();
                if (d?.answer && !peerConnection.remoteDescription) {
                    try { await peerConnection.setRemoteDescription(new RTCSessionDescription(d.answer)); await flushBuffer(); unsub(); } catch(e) {}
                }
            });
        } else {
            const unsub = onSnapshot(doc(db,'matches',matchId), async (snap) => {
                const d = snap.data();
                if (d?.offer && !peerConnection.remoteDescription) {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(d.offer));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        await updateDoc(doc(db,'matches',matchId), { answer: {type:answer.type, sdp:answer.sdp} });
                        await flushBuffer(); unsub();
                    } catch(e) {}
                }
            });
        }
    } catch(error) {
        console.error('WebRTC setup error:', error);
        showToast('Connection setup failed. Please try again.');
    }
}

let disconnectionHandled = false;
async function handlePartnerDisconnection() {
    if (disconnectionHandled) return;
    disconnectionHandled = true;
    try {
        timerPaused = true;
        document.getElementById('reconnectingOverlay').classList.add('active');
        document.getElementById('reconnectingMessage').textContent = 'Partner left. Finding new partner...';
        if (peerConnection) { peerConnection.close(); peerConnection = null; }
        if (remoteStream) { remoteStream.getTracks().forEach(t=>t.stop()); remoteStream = null; document.getElementById('remoteVideo').srcObject = null; }
        if (matchId) { try { await updateDoc(doc(db,'matches',matchId), {status:'completed'}); } catch(e) {} }

        matchId = null; matchHandled = false; partnerId = null;

        const seenIds = new Set();
        const q = query(collection(db,'matches'), where('users','array-contains',currentUser.uid));
        (await getDocs(q)).forEach(d => seenIds.add(d.id));

        const queueRef = doc(db,'match_queue',currentUser.uid);
        await setDoc(queueRef, { userId:currentUser.uid, level:userData.level||'A1', streak:userData.streakDays||1, displayName:getUserDisplayName(), timestamp:serverTimestamp(), lastSeen:serverTimestamp(), status:'waiting' });
        startQueueHeartbeat();

        let unsubM;
        const unsubQ = onSnapshot(queueRef, async (snap) => {
            const d = snap.data();
            if (d?.matchId && d?.status==='matched' && !matchHandled && !seenIds.has(d.matchId)) {
                matchHandled = true; matchId = d.matchId;
                stopQueueHeartbeat(); unsubQ(); if (unsubM) unsubM();
                document.getElementById('reconnectingOverlay').classList.remove('active');
                disconnectionHandled = false;
                await handleMatchFound();
            }
        });
        unsubM = onSnapshot(q, async (snap) => {
            for (const change of snap.docChanges()) {
                if (change.type==='added' && !seenIds.has(change.doc.id)) {
                    seenIds.add(change.doc.id);
                    const d = change.doc.data();
                    if (d.status==='active' && !matchHandled) {
                        matchHandled = true; matchId = change.doc.id;
                        stopQueueHeartbeat(); unsubQ(); unsubM();
                        try { await updateDoc(queueRef, {matchId:matchId,status:'matched'}); } catch(e) {}
                        document.getElementById('reconnectingOverlay').classList.remove('active');
                        disconnectionHandled = false;
                        await handleMatchFound();
                    }
                }
            }
        });
        setTimeout(() => findMatch(), 1000);
    } catch(e) {
        console.error('Disconnection error:', e);
        setTimeout(() => { document.getElementById('reconnectingOverlay').classList.remove('active'); endSession(); }, 2000);
    }
}

window.toggleAudio = () => { if (localStream) { const t=localStream.getAudioTracks()[0]; t.enabled=!t.enabled; document.getElementById('toggleAudio').textContent=t.enabled?'ğŸ¤ Mute':'ğŸ”‡ Unmute'; } };
window.toggleVideo = () => { if (localStream) { const t=localStream.getVideoTracks()[0]; t.enabled=!t.enabled; document.getElementById('toggleVideo').textContent=t.enabled?'ğŸ“¹ Stop Video':'ğŸ“¹ Start Video'; } };
window.changeTask = async () => {
    if (!matchId || !userData) return;
    const newTask = getRandomTask(userData.level||'A1'); currentTask = newTask;
    await updateDoc(doc(db,'matches',matchId), {task:newTask, taskChangedAt:serverTimestamp()});
    displayTask(newTask); showToast('âœ… Task changed: ' + newTask.type);
};
window.addExtraTime = () => {
    if (timeExtensionUsed) { showToast('â° Time already added'); return; }
    timeRemaining+=600; sessionDuration+=600; timeExtensionUsed=true;
    document.getElementById('btnAddTime').disabled=true;
    document.getElementById('btnAddTime').textContent='â° Time Added';
    showToast('âœ… Added 10 minutes!');
    if (matchId) updateDoc(doc(db,'matches',matchId), {timeExtended:true, extendedAt:serverTimestamp()}).catch(()=>{});
};
window.endSession = () => {
    if (sessionTimer) clearInterval(sessionTimer);
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
    if (peerConnection) peerConnection.close();
    if (matchId) updateDoc(doc(db,'matches',matchId), {status:'completed'}).catch(()=>{});
    showState('evaluationState');
    setupEvaluationListeners();
};

function setupEvaluationListeners() {
    document.querySelectorAll('.rating-buttons').forEach(container => {
        const criteria = container.dataset.criteria;
        container.querySelectorAll('.rating-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                container.querySelectorAll('.rating-btn').forEach(b=>b.classList.remove('selected'));
                btn.classList.add('selected');
                evaluationScores[criteria] = parseInt(btn.dataset.value);
                document.getElementById('submitEvaluation').disabled = !Object.values(evaluationScores).every(s=>s>0);
            });
        });
    });
}

window.submitEvaluation = async () => {
    await updateDoc(doc(db,'matches',matchId), { [`evaluations.${currentUser.uid}`]:evaluationScores, [`completed.${currentUser.uid}`]:true, status:'completed' });
    await updateDoc(doc(db,'users',currentUser.uid), { totalScore:(userData.totalScore||0)+50, weeklyScore:(userData.weeklyScore||0)+50, sessionsCompleted:(userData.sessionsCompleted||0)+1 });
    await deleteDoc(doc(db,'match_queue',currentUser.uid));
    document.getElementById('resultFluency').textContent = Math.floor(Math.random()*2)+4;
    document.getElementById('resultVocabulary').textContent = Math.floor(Math.random()*2)+3;
    document.getElementById('resultGrammar').textContent = Math.floor(Math.random()*2)+3;
    document.getElementById('resultTaskCompletion').textContent = Math.floor(Math.random()*2)+4;
    showState('resultsState');
};
window.cancelMatching = async () => {
    stopQueueHeartbeat();
    if (matchId) { try { await updateDoc(doc(db,'matches',matchId),{status:'cancelled'}); } catch(e) {} }
    await deleteDoc(doc(db,'match_queue',currentUser.uid));
    window.location.href = 'dashboard.html';
};
window.practiceAgain = () => { evaluationScores={fluency:0,vocabulary:0,grammar:0,taskCompletion:0}; matchId=null; matchHandled=false; partnerDisplayName='Partner'; location.reload(); };
window.backToDashboard = () => { window.location.href='dashboard.html'; };

window.addEventListener('beforeunload', async () => {
    stopQueueHeartbeat();
    if (localStream) localStream.getTracks().forEach(t=>t.stop());
    if (peerConnection) peerConnection.close();
    if (currentUser) {
        try {
            await deleteDoc(doc(db,'match_queue',currentUser.uid));
            if (matchId) await updateDoc(doc(db,'matches',matchId), {[`disconnected.${currentUser.uid}`]:true, status:'completed'});
        } catch(e) {}
    }
});
</script>
<a href="ai-partner.html" class="ai-fab" id="aiFab">ğŸ¤– <span class="fab-text">AI Practice</span></a>
</body>
</html>
