<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprechen Buddy - German Made Easy</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .card {
            background: white;
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(135deg, #FF6B35, #004E89);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 18px;
        }

        /* States */
        .state {
            display: none;
        }

        .state.active {
            display: block;
        }

        /* Waiting State */
        .waiting-animation {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid #f3f3f3;
            border-top: 8px solid #FF6B35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .waiting-text {
            font-size: 24px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .waiting-subtext {
            color: #666;
            font-size: 16px;
            margin-bottom: 30px;
        }

        .queue-info {
            background: #FFF3ED;
            border: 2px solid #FF6B35;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .queue-info p {
            font-size: 15px;
            color: #1A1A2E;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        /* Match Found */
        .match-found {
            text-align: center;
            padding: 40px 20px;
        }

        .match-emoji {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .match-text {
            font-size: 28px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 10px;
        }

        .partner-info {
            background: #f8f8f8;
            border-radius: 16px;
            padding: 20px;
            margin: 30px 0;
        }

        .partner-info h3 {
            font-size: 18px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #666;
            font-weight: 600;
        }

        .info-value {
            color: #1A1A2E;
            font-weight: 700;
        }

        /* Task Card */
        .task-card {
            background: linear-gradient(135deg, #FFF3ED, #FFE8DC);
            border: 3px solid #FF6B35;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .task-type {
            background: #FF6B35;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 700;
        }

        .task-level {
            font-size: 24px;
            font-weight: 900;
            color: #FF6B35;
        }

        .task-scenario {
            margin-bottom: 20px;
        }

        .scenario-label {
            font-size: 12px;
            text-transform: uppercase;
            font-weight: 700;
            color: #666;
            margin-bottom: 8px;
        }

        .scenario-text {
            font-size: 18px;
            color: #1A1A2E;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .scenario-gujarati {
            font-size: 16px;
            color: #666;
            font-style: italic;
        }

        .task-questions {
            background: white;
            border-radius: 12px;
            padding: 20px;
        }

        .task-questions h4 {
            font-size: 16px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .task-questions ul {
            list-style: none;
        }

        .task-questions li {
            padding: 10px 0;
            border-bottom: 1px solid #f0f0f0;
            color: #1A1A2E;
        }

        .task-questions li:last-child {
            border-bottom: none;
        }

        /* Timer */
        .timer-section {
            text-align: center;
            margin: 30px 0;
        }

        .timer-display {
            font-size: 72px;
            font-weight: 900;
            color: #FF6B35;
            margin-bottom: 10px;
            font-variant-numeric: tabular-nums;
        }

        .timer-display.warning {
            color: #f59e0b;
            animation: pulse 1s infinite;
        }

        .timer-display.danger {
            color: #ef4444;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .timer-label {
            font-size: 16px;
            color: #666;
            font-weight: 600;
        }

        /* Video Section */
        .video-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-container {
            position: relative;
            background: #1A1A2E;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 4/3;
        }

        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }

        .connection-status {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #FF6B35, #004E89);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 53, 0.4);
        }

        .btn-secondary {
            background: white;
            color: #FF6B35;
            border: 2px solid #FF6B35;
        }

        .btn-secondary:hover {
            background: #FFF3ED;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Evaluation Form */
        .evaluation-form {
            background: #f8f8f8;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .evaluation-form h3 {
            font-size: 20px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 20px;
            text-align: center;
        }

        .criteria-item {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .criteria-item:last-child {
            margin-bottom: 0;
        }

        .criteria-label {
            font-size: 16px;
            font-weight: 600;
            color: #1A1A2E;
            margin-bottom: 12px;
        }

        .rating-buttons {
            display: flex;
            gap: 10px;
        }

        .rating-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rating-btn:hover {
            border-color: #FF6B35;
            background: #FFF3ED;
        }

        .rating-btn.selected {
            border-color: #FF6B35;
            background: #FF6B35;
            color: white;
        }

        /* Results */
        .results-section {
            text-align: center;
            padding: 40px 20px;
        }

        .results-emoji {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .results-title {
            font-size: 28px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .points-earned {
            background: linear-gradient(135deg, #FFF3ED, #FFE8DC);
            border: 3px solid #FF6B35;
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
        }

        .points-number {
            font-size: 48px;
            font-weight: 900;
            color: #FF6B35;
            margin-bottom: 10px;
        }

        .points-label {
            font-size: 18px;
            color: #666;
        }

        .feedback-section {
            background: #f8f8f8;
            border-radius: 16px;
            padding: 25px;
            margin: 20px 0;
            text-align: left;
        }

        .feedback-section h4 {
            font-size: 18px;
            font-weight: 700;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .feedback-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .feedback-item:last-child {
            border-bottom: none;
        }

        .feedback-label {
            color: #666;
            font-weight: 600;
        }

        .feedback-score {
            font-weight: 700;
            color: #FF6B35;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .card {
                padding: 25px;
            }

            .header h1 {
                font-size: 28px;
            }

            .video-section {
                grid-template-columns: 1fr;
            }

            .timer-display {
                font-size: 56px;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }

            .rating-buttons {
                flex-direction: column;
            }
        }
    
        
        /* Advanced Feature Buttons */
        .btn-change-task {
            padding: 12px 24px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-change-task:hover {
            background: #059669;
        }

        .btn-add-time {
            padding: 12px 24px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-add-time:hover {
            background: #d97706;
        }

        .btn-add-time:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .reconnecting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .reconnecting-overlay.active {
            display: flex;
        }

        .reconnecting-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
        }

        .reconnecting-card h3 {
            font-size: 24px;
            color: #1A1A2E;
            margin-bottom: 15px;
        }

        .reconnecting-card p {
            color: #666;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header">
                <h1>ğŸ—£ï¸ Sprechen Buddy</h1>
                <p>Practice speaking German with real students</p>
            </div>

            <!-- Waiting State -->
            <div id="waitingState" class="state active">
                <div class="waiting-animation">
                    <div class="spinner"></div>
                    <div class="waiting-text">Finding your practice partner...</div>
                    <div class="waiting-subtext">This usually takes 30-60 seconds</div>
                    
                    <div class="queue-info">
                        <p>ğŸ‘¥ <strong><span id="queueCount">0</span> students</strong> are waiting to practice</p>
                        <p>ğŸ”¥ You'll be matched with the next available student</p>
                        <p>â±ï¸ Average wait time: <strong>45 seconds</strong></p>
                    </div>

                    <button class="btn btn-danger" onclick="cancelMatching()">Cancel</button>
                </div>
            </div>

            <!-- Match Found State -->
            <div id="matchFoundState" class="state">
                <div class="match-found">
                    <div class="match-emoji">ğŸ‰</div>
                    <div class="match-text">Match Found!</div>
                    <p id="matchStatusText" style="color: #666; margin-bottom: 30px;">Connecting you with your practice partner...</p>

                    <div class="partner-info">
                        <h3>Your Partner</h3>
                        <div class="info-row">
                            <span class="info-label">Name</span>
                            <span class="info-value" id="partnerName">Loading...</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Level</span>
                            <span class="info-value" id="partnerLevel">A2</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Streak</span>
                            <span class="info-value">ğŸ”¥ <span id="partnerStreak">7</span> days</span>
                        </div>
                    </div>

                    <p style="color: #999; font-size: 14px; margin-top: 20px;">
                        ğŸ“ Your partner's account name is shown above. Happy practicing!
                    </p>
                </div>
            </div>

            <!-- Session State -->
            <div id="sessionState" class="state">
                <!-- Task Card -->
                <div class="task-card">
                    <div class="task-header">
                        <div class="task-type" id="taskType">Planning Together</div>
                        <div class="task-level" id="taskLevel">A2</div>
                    </div>
                    
                    <div class="task-scenario">
                        <div class="scenario-label">SCENARIO / àªªàª°àª¿àª¸à«àª¥àª¿àª¤àª¿</div>
                        <div class="scenario-text" id="scenarioGerman">
                            Sie mÃ¶chten mit Ihrem Partner am Wochenende einen Ausflug machen.
                        </div>
                        <div class="scenario-gujarati" id="scenarioGujarati">
                            àª¤àª®à«‡ àª…àª¨à«‡ àª¤àª®àª¾àª°àª¾ àªªàª¾àª°à«àªŸàª¨àª° àª¸àªªà«àª¤àª¾àª¹àª¾àª‚àª¤àª®àª¾àª‚ àªàª• àªªàª°à«àª¯àªŸàª¨ àª•àª°àªµàª¾ àª®àª¾àª‚àª—à«‹ àª›à«‹.
                        </div>
                    </div>

                    <div class="task-questions">
                        <h4>Diskutieren Sie Ã¼ber:</h4>
                        <ul id="questionsList">
                            <li>Wohin mÃ¶chten Sie fahren?</li>
                            <li>Wann sollen Sie fahren?</li>
                            <li>Was mÃ¶chten Sie dort machen?</li>
                            <li>Wie lange mÃ¶chten Sie bleiben?</li>
                        </ul>
                    </div>
                </div>

                <!-- Timer -->
                <div class="timer-section">
                    <div class="timer-display" id="timerDisplay">08:00</div>
                    <div class="timer-label">Time Remaining</div>
                </div>

                <!-- Video Section -->
                <div class="video-section">
                    <div class="video-container">
                        <video id="localVideo" autoplay muted playsinline></video>
                        <div class="video-label">You</div>
                        <div class="connection-status">
                            <div class="status-dot"></div>
                            <span>Local</span>
                        </div>
                    </div>
                    <div class="video-container">
                        <video id="remoteVideo" autoplay playsinline></video>
                        <div class="video-label" id="remoteLabel">Partner</div>
                        <div class="connection-status" id="remoteConnectionStatus">
                            <div class="status-dot" id="remoteStatusDot" style="background: #f59e0b;"></div>
                            <span id="remoteStatusText">Connecting...</span>
                        </div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="controls">
                    <button class="btn btn-secondary" id="toggleAudio" onclick="toggleAudio()">
                        ğŸ¤ Mute
                    </button>
                    <button class="btn btn-secondary" id="toggleVideo" onclick="toggleVideo()">
                        ğŸ“¹ Stop Video
                    </button>
                    <button class="btn-change-task" onclick="changeTask()">
                        ğŸ”„ Change Task
                    </button>
                    <button class="btn-add-time" id="btnAddTime" onclick="addExtraTime()">
                        â° +10 Minutes
                    </button>
                    <button class="btn btn-danger" onclick="endSession()">
                        âŒ End Session
                    </button>
                </div>

                <div class="reconnecting-overlay" id="reconnectingOverlay">
                    <div class="reconnecting-card">
                        <div class="spinner"></div>
                        <h3>Partner Left</h3>
                        <p id="reconnectingMessage">Finding new partner...</p>
                    </div>
                </div>

                <p style="text-align: center; color: #999; font-size: 14px; margin-top: 20px;">
                    ğŸ’¡ Speak naturally! Your partner is also learning. Help each other!
                </p>
            </div>

            <!-- Evaluation State -->
            <div id="evaluationState" class="state">
                <div class="evaluation-form">
                    <h3>Evaluate Your Partner ğŸ“Š</h3>
                    <p style="text-align: center; color: #666; margin-bottom: 30px;">
                        Rate your partner on these 4 criteria (1 = needs work, 5 = excellent)
                    </p>

                    <div class="criteria-item">
                        <div class="criteria-label">ğŸ—£ï¸ Fluency (àª•à«‡àªŸàª²à«€ àª°àªµàª¾àª¨à«€ àª°à«€àª¤à«‡ àª¬à«‹àª²à«àª¯àª¾?)</div>
                        <div class="rating-buttons" data-criteria="fluency">
                            <button class="rating-btn" data-value="1">1</button>
                            <button class="rating-btn" data-value="2">2</button>
                            <button class="rating-btn" data-value="3">3</button>
                            <button class="rating-btn" data-value="4">4</button>
                            <button class="rating-btn" data-value="5">5</button>
                        </div>
                    </div>

                    <div class="criteria-item">
                        <div class="criteria-label">ğŸ“š Vocabulary (àª¶àª¬à«àª¦àª­àª‚àª¡à«‹àª³)</div>
                        <div class="rating-buttons" data-criteria="vocabulary">
                            <button class="rating-btn" data-value="1">1</button>
                            <button class="rating-btn" data-value="2">2</button>
                            <button class="rating-btn" data-value="3">3</button>
                            <button class="rating-btn" data-value="4">4</button>
                            <button class="rating-btn" data-value="5">5</button>
                        </div>
                    </div>

                    <div class="criteria-item">
                        <div class="criteria-label">âœ… Grammar (àªµà«àª¯àª¾àª•àª°àª£)</div>
                        <div class="rating-buttons" data-criteria="grammar">
                            <button class="rating-btn" data-value="1">1</button>
                            <button class="rating-btn" data-value="2">2</button>
                            <button class="rating-btn" data-value="3">3</button>
                            <button class="rating-btn" data-value="4">4</button>
                            <button class="rating-btn" data-value="5">5</button>
                        </div>
                    </div>

                    <div class="criteria-item">
                        <div class="criteria-label">ğŸ¯ Task Completion (àª•à«‡àªŸàª²à«àª‚ àª¸àª¾àª°à«àª‚ àªªà«‚àª°à«àª£ àª•àª°à«àª¯à«àª‚?)</div>
                        <div class="rating-buttons" data-criteria="taskCompletion">
                            <button class="rating-btn" data-value="1">1</button>
                            <button class="rating-btn" data-value="2">2</button>
                            <button class="rating-btn" data-value="3">3</button>
                            <button class="rating-btn" data-value="4">4</button>
                            <button class="rating-btn" data-value="5">5</button>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="submitEvaluation" onclick="submitEvaluation()" disabled>
                        Submit Evaluation âœ…
                    </button>
                </div>
            </div>

            <!-- Results State -->
            <div id="resultsState" class="state">
                <div class="results-section">
                    <div class="results-emoji">ğŸ‰</div>
                    <div class="results-title">Great Practice Session!</div>
                    <p style="color: #666; margin-bottom: 30px;">
                        You both completed the speaking task successfully
                    </p>

                    <div class="points-earned">
                        <div class="points-number">+50</div>
                        <div class="points-label">Points Earned</div>
                    </div>

                    <div class="feedback-section">
                        <h4>Your Partner's Evaluation</h4>
                        <div class="feedback-item">
                            <span class="feedback-label">Fluency</span>
                            <span class="feedback-score"><span id="resultFluency">4</span>/5</span>
                        </div>
                        <div class="feedback-item">
                            <span class="feedback-label">Vocabulary</span>
                            <span class="feedback-score"><span id="resultVocabulary">4</span>/5</span>
                        </div>
                        <div class="feedback-item">
                            <span class="feedback-label">Grammar</span>
                            <span class="feedback-score"><span id="resultGrammar">3</span>/5</span>
                        </div>
                        <div class="feedback-item">
                            <span class="feedback-label">Task Completion</span>
                            <span class="feedback-score"><span id="resultTaskCompletion">5</span>/5</span>
                        </div>
                    </div>

                    <div class="controls">
                        <button class="btn btn-primary" onclick="practiceAgain()">
                            ğŸ”„ Practice Again
                        </button>
                        <button class="btn btn-secondary" onclick="backToDashboard()">
                            ğŸ  Back to Dashboard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, onSnapshot, deleteDoc, collection, query, where, getDocs, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDx2fBrlxNP_zs0xra8ccXyCHQtnHud30E",
            authDomain: "german-made-easy.firebaseapp.com",
            projectId: "german-made-easy",
            storageBucket: "german-made-easy.firebasestorage.app",
            messagingSenderId: "259276936055",
            appId: "1:259276936055:web:5c9b4916734d0271100772",
            measurementId: "G-B7JMB0G85L"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Global variables
        let currentUser = null;
        let userData = null;
        let matchId = null;
        let matchHandled = false;
        let partnerDisplayName = 'Partner';
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let sessionTimer = null;
        let sessionDuration = 1200; // 20 minutes
        let timeRemaining = 1200;
        let timerPaused = false;
        let timeExtensionUsed = false;
        let currentTask = null;
        let partnerId = null; // 8 minutes
        let evaluationScores = {
            fluency: 0,
            vocabulary: 0,
            grammar: 0,
            taskCompletion: 0
        };

        // WebRTC configuration - STUN servers for NAT traversal (P2P only)
        // Note: Without TURN servers, calls may fail when both users are
        // behind symmetric NATs or restrictive firewalls (~15-30% of cases).
        // For reliable cross-network calls, add a free TURN service like
        // Metered.ca (50GB/month free, no credit card): https://www.metered.ca/signup
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        };

        // Task library (sample tasks)
        const tasks = {
            A1: [
                {
                    type: "Introduction",
                    scenario_german: "Sie treffen zum ersten Mal Ihren Sprachpartner.",
                    scenario_gujarati: "àª¤àª®à«‡ àªªà«àª°àª¥àª® àªµàª–àª¤ àª¤àª®àª¾àª°àª¾ àª­àª¾àª·àª¾ àªªàª¾àª°à«àªŸàª¨àª°àª¨à«‡ àª®àª³à«‹ àª›à«‹.",
                    questions: [
                        "Wie heiÃŸen Sie?",
                        "Woher kommen Sie?",
                        "Was machen Sie?",
                        "Was sind Ihre Hobbys?"
                    ]
                },
                {
                    type: "Shopping",
                    scenario_german: "Sie sind im Supermarkt und brauchen Hilfe.",
                    scenario_gujarati: "àª¤àª®à«‡ àª¸à«àªªàª°àª®àª¾àª°à«àª•à«‡àªŸàª®àª¾àª‚ àª›à«‹ àª…àª¨à«‡ àª®àª¦àª¦àª¨à«€ àªœàª°à«‚àª° àª›à«‡.",
                    questions: [
                        "Was mÃ¶chten Sie kaufen?",
                        "Wo finden Sie das?",
                        "Wie viel kostet das?",
                        "Zahlen Sie bar oder mit Karte?"
                    ]
                }
            ],
            A2: [
                {
                    type: "Planning Together",
                    scenario_german: "Sie mÃ¶chten mit Ihrem Partner am Wochenende einen Ausflug machen.",
                    scenario_gujarati: "àª¤àª®à«‡ àª…àª¨à«‡ àª¤àª®àª¾àª°àª¾ àªªàª¾àª°à«àªŸàª¨àª° àª¸àªªà«àª¤àª¾àª¹àª¾àª‚àª¤àª®àª¾àª‚ àªàª• àªªàª°à«àª¯àªŸàª¨ àª•àª°àªµàª¾ àª®àª¾àª‚àª—à«‹ àª›à«‹.",
                    questions: [
                        "Wohin mÃ¶chten Sie fahren?",
                        "Wann sollen Sie fahren?",
                        "Was mÃ¶chten Sie dort machen?",
                        "Wie lange mÃ¶chten Sie bleiben?"
                    ]
                },
                {
                    type: "Restaurant",
                    scenario_german: "Sie gehen zusammen in ein Restaurant essen.",
                    scenario_gujarati: "àª¤àª®à«‡ àª¸àª¾àª¥à«‡ àªàª• àª°à«‡àª¸à«àªŸà«‹àª°àª¨à«àªŸàª®àª¾àª‚ àªœàª®àªµàª¾ àªœàª¾àª“ àª›à«‹.",
                    questions: [
                        "Welches Restaurant mÃ¶chten Sie besuchen?",
                        "Was mÃ¶chten Sie essen?",
                        "Wann mÃ¶chten Sie reservieren?",
                        "Wie teilen Sie die Rechnung?"
                    ]
                }
            ]
        };

        // Get user's real display name from their account
        function getUserDisplayName() {
            return userData.name || currentUser.displayName || currentUser.email.split('@')[0];
        }

        function getRandomTask(level) {
            const levelTasks = tasks[level] || tasks.A1;
            return levelTasks[Math.floor(Math.random() * levelTasks.length)];
        }

        // State management
        function showState(stateName) {
            document.querySelectorAll('.state').forEach(el => el.classList.remove('active'));
            document.getElementById(stateName).classList.add('active');
        }

        // Initialize
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                window.location.href = 'login.html';
                return;
            }

            currentUser = user;
            const userDoc = await getDoc(doc(db, 'users', user.uid));
            userData = userDoc.data();

            // Start matching process
            startMatching();
        });


        // Clean up stale queue entries on load
        async function cleanupStaleEntries() {
            if (!currentUser) return;
            
            try {
                // 1. Clean up from previous dirty session (if beforeunload didn't complete)
                const dirtyUid = sessionStorage.getItem('sprechen_dirty_uid');
                const dirtyMatch = sessionStorage.getItem('sprechen_dirty_match');
                if (dirtyUid) {
                    sessionStorage.removeItem('sprechen_dirty_uid');
                    sessionStorage.removeItem('sprechen_dirty_match');
                    console.log('ğŸ§¹ Cleaning up dirty session from previous page');
                    try { await deleteDoc(doc(db, 'match_queue', dirtyUid)); } catch(e) {}
                    if (dirtyMatch) {
                        try { await updateDoc(doc(db, 'matches', dirtyMatch), { status: 'completed' }); } catch(e) {}
                    }
                }
                
                // 2. Remove any existing queue entry for this user
                const queueDoc = await getDoc(doc(db, 'match_queue', currentUser.uid));
                if (queueDoc.exists()) {
                    console.log('ğŸ§¹ Removing stale queue entry');
                    await deleteDoc(doc(db, 'match_queue', currentUser.uid));
                }

                // 3. Mark ALL old matches involving this user as completed
                // This is critical â€” wait for this before attaching listeners
                const staleQuery = query(
                    collection(db, 'matches'),
                    where('users', 'array-contains', currentUser.uid)
                );
                const staleSnapshot = await getDocs(staleQuery);
                const cleanups = [];
                staleSnapshot.forEach(matchDoc => {
                    const data = matchDoc.data();
                    if (data.status !== 'completed' && data.status !== 'cancelled') {
                        console.log(`ğŸ§¹ Marking stale match ${matchDoc.id} as completed (was: ${data.status})`);
                        cleanups.push(
                            updateDoc(doc(db, 'matches', matchDoc.id), { status: 'completed' })
                        );
                    }
                });
                if (cleanups.length > 0) {
                    await Promise.all(cleanups);
                    // Give Firestore a moment to propagate so listeners don't pick them up
                    await new Promise(r => setTimeout(r, 500));
                }
                console.log(`ğŸ§¹ Cleanup complete (${cleanups.length} stale matches cleared)`);
            } catch (error) {
                console.error('Stale cleanup error:', error);
            }
        }

        let queueHeartbeat = null;
        
        function startQueueHeartbeat() {
            if (queueHeartbeat) clearInterval(queueHeartbeat);
            
            queueHeartbeat = setInterval(async () => {
                if (currentUser && matchId === null) { // Only if still waiting
                    try {
                        const queueRef = doc(db, 'match_queue', currentUser.uid);
                        const queueDoc = await getDoc(queueRef);
                        
                        if (queueDoc.exists()) {
                            await updateDoc(queueRef, {
                                lastSeen: serverTimestamp()
                            });
                            console.log('ğŸ’“ Queue heartbeat sent');
                        } else {
                            // Queue entry doesn't exist, stop heartbeat
                            clearInterval(queueHeartbeat);
                        }
                    } catch (error) {
                        console.error('Heartbeat error:', error);
                    }
                }
            }, 10000); // Every 10 seconds
        }
        
        function stopQueueHeartbeat() {
            if (queueHeartbeat) {
                clearInterval(queueHeartbeat);
                queueHeartbeat = null;
                console.log('ğŸ’” Queue heartbeat stopped');
            }
        }

        async function verifyPartnerOnline(partnerId) {
            try {
                const partnerQueue = await getDoc(doc(db, 'match_queue', partnerId));
                
                if (!partnerQueue.exists()) {
                    console.log('âš ï¸ Partner not in queue anymore');
                    return false;
                }
                
                const data = partnerQueue.data();
                const lastSeen = data.lastSeen?.toMillis() || data.timestamp?.toMillis() || 0;
                const age = Date.now() - lastSeen;
                
                // Partner must have been seen in last 30 seconds
                if (age > 30000) {
                    console.log(`âš ï¸ Partner inactive (${Math.floor(age/1000)}s ago)`);
                    return false;
                }
                
                console.log(`âœ… Partner verified (active ${Math.floor(age/1000)}s ago)`);
                return true;
            } catch (error) {
                console.error('Partner verification error:', error);
                return false;
            }
        }

        let matchFoundTimeout = null;
        
        function startMatchFoundTimeout() {
            matchFoundTimeout = setTimeout(() => {
                console.log('â±ï¸ Match found timeout - partner never joined');
                showNotification('Partner did not join. Searching again...', 'important');
                
                // Clean up and restart matching
                if (matchId) {
                    updateDoc(doc(db, 'matches', matchId), {
                        status: 'cancelled',
                        reason: 'Partner did not join'
                    }).catch(e => {});
                }
                
                matchId = null;
                location.reload(); // Refresh to restart
            }, 15000); // 15 seconds
        }
        
        function clearMatchFoundTimeout() {
            if (matchFoundTimeout) {
                clearTimeout(matchFoundTimeout);
                matchFoundTimeout = null;
            }
        }
        async function startMatching() {
            showState('waitingState');
            
            // Clean up any stale entries FIRST â€” this now handles everything
            // including old matches, so we removed the duplicate cleanup below.
            await cleanupStaleEntries();

            // Prevent rejoining active session
            if (matchId) {
                showNotification('âŒ Cannot rejoin active session', 'important');
                console.log('Blocked: Trying to rejoin active match');
                return;
            }
            
            // Create or update match queue entry with real name
            const queueRef = doc(db, 'match_queue', currentUser.uid);
            await setDoc(queueRef, {
                userId: currentUser.uid,
                level: userData.level || 'A1',
                streak: userData.streakDays || 1,
                displayName: getUserDisplayName(),
                timestamp: serverTimestamp(),
                lastSeen: serverTimestamp(),
                status: 'waiting'
            });

            // Start heartbeat so others know we're alive
            startQueueHeartbeat();

            // Update queue count
            updateQueueCount();

            let unsubQueue = null;
            let unsubMatches = null;

            // Listen for changes to own queue entry (fires when match creator updates it)
            unsubQueue = onSnapshot(queueRef, async (snapshot) => {
                const queueData = snapshot.data();
                if (queueData && queueData.matchId && !matchHandled) {
                    matchHandled = true;
                    matchId = queueData.matchId;
                    stopQueueHeartbeat();
                    if (unsubQueue) unsubQueue();
                    if (unsubMatches) unsubMatches();
                    await handleMatchFound();
                }
            });

            // Also listen for match documents where this user is a participant.
            // IMPORTANT: We track which match IDs we've already seen so we only
            // react to genuinely NEW matches, not leftover ones from cleanup.
            const seenMatchIds = new Set();

            const matchesQuery = query(
                collection(db, 'matches'),
                where('users', 'array-contains', currentUser.uid)
            );

            // Get current matches to mark as "already seen"
            const existingMatches = await getDocs(matchesQuery);
            existingMatches.forEach(d => seenMatchIds.add(d.id));

            unsubMatches = onSnapshot(matchesQuery, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && !seenMatchIds.has(change.doc.id)) {
                        seenMatchIds.add(change.doc.id);
                        const matchData = change.doc.data();
                        if (matchData.status === 'active' && !matchHandled) {
                            matchHandled = true;
                            matchId = change.doc.id;
                            stopQueueHeartbeat();
                            try {
                                await updateDoc(queueRef, {
                                    matchId: matchId,
                                    status: 'matched'
                                });
                            } catch (e) {
                                console.log('Queue entry update skipped:', e);
                            }
                            if (unsubQueue) unsubQueue();
                            if (unsubMatches) unsubMatches();
                            await handleMatchFound();
                        }
                    }
                });
            });

            // Clean up listeners on page unload
            window.addEventListener('beforeunload', () => {
                if (unsubQueue) unsubQueue();
                if (unsubMatches) unsubMatches();
            });

            // Try to find match after a short delay
            setTimeout(() => findMatch(), 2000);
        }

        async function findMatch() {
            // Don't search if already matched
            if (matchId || matchHandled) return;

            try {
                const queueRef = collection(db, 'match_queue');
                const q = query(
                    queueRef,
                    where('status', '==', 'waiting')
                );

                const snapshot = await getDocs(q);
                const candidates = [];
                const now = Date.now();
                const STALE_THRESHOLD = 30000; // 30 seconds â€” must have heartbeat within this

                snapshot.forEach(docSnap => {
                    if (docSnap.id !== currentUser.uid) {
                        const data = docSnap.data();
                        const lastSeen = data.lastSeen?.toMillis() || data.timestamp?.toMillis() || 0;
                        const age = now - lastSeen;
                        
                        if (age < STALE_THRESHOLD) {
                            candidates.push({ id: docSnap.id, ...data, age });
                        } else {
                            // Clean up stale entry
                            console.log(`ğŸ—‘ï¸ Removing stale queue entry: ${docSnap.id} (${Math.floor(age/1000)}s old)`);
                            deleteDoc(docSnap.ref).catch(() => {});
                        }
                    }
                });

                if (candidates.length > 0 && !matchId && !matchHandled) {
                    // Sort by freshness â€” match with most recently active user
                    candidates.sort((a, b) => a.age - b.age);
                    const partner = candidates[0];
                    
                    // Double-check partner is still alive before creating match
                    const isOnline = await verifyPartnerOnline(partner.id);
                    if (!isOnline) {
                        console.log('âš ï¸ Best candidate was stale, retrying...');
                        if (!matchId && !matchHandled) {
                            setTimeout(() => findMatch(), 2000);
                        }
                        return;
                    }

                    const newMatchId = `match_${Date.now()}_${currentUser.uid.substring(0, 6)}`;

                    // Create match document with both users' display names
                    await setDoc(doc(db, 'matches', newMatchId), {
                        users: [currentUser.uid, partner.id],
                        userNames: {
                            [currentUser.uid]: getUserDisplayName(),
                            [partner.id]: partner.displayName || 'Student'
                        },
                        level: userData.level || 'A1',
                        task: getRandomTask(userData.level || 'A1'),
                        startTime: serverTimestamp(),
                        status: 'active'
                    });

                    // Update own queue entry (always succeeds)
                    await updateDoc(doc(db, 'match_queue', currentUser.uid), {
                        matchId: newMatchId,
                        status: 'matched'
                    });

                    // Try to update partner's queue entry
                    try {
                        await updateDoc(doc(db, 'match_queue', partner.id), {
                            matchId: newMatchId,
                            status: 'matched'
                        });
                    } catch (e) {
                        console.log('Partner will detect match via matches listener');
                    }
                } else if (!matchId && !matchHandled) {
                    // Keep waiting, check again
                    setTimeout(() => findMatch(), 3000);
                }
            } catch (error) {
                console.error('Error in findMatch:', error);
                if (!matchId && !matchHandled) {
                    setTimeout(() => findMatch(), 3000);
                }
            }
        }

        async function updateQueueCount() {
            const queueRef = collection(db, 'match_queue');
            const q = query(queueRef, where('status', '==', 'waiting'));
            const snapshot = await getDocs(q);
            document.getElementById('queueCount').textContent = snapshot.size;
        }

        async function handleMatchFound() {
            showState('matchFoundState');

            const statusText = document.getElementById('matchStatusText');
            statusText.textContent = 'Waiting for your partner to join...';

            // Get match details
            const matchDocSnap = await getDoc(doc(db, 'matches', matchId));
            const matchData = matchDocSnap.data();

            // Find partner
            const foundPartnerId = matchData.users.find(id => id !== currentUser.uid);
            // Update the global partnerId
            partnerId = foundPartnerId;

            // Get partner's display name from match document
            partnerDisplayName = 'Student';
            let partnerLevel = matchData.level || 'A1';
            let partnerStreak = 1;

            if (matchData.userNames && matchData.userNames[foundPartnerId]) {
                partnerDisplayName = matchData.userNames[foundPartnerId];
            }

            // Try to get additional info from partner's queue entry
            try {
                const partnerQueue = await getDoc(doc(db, 'match_queue', foundPartnerId));
                if (partnerQueue.exists()) {
                    const partnerData = partnerQueue.data();
                    if (partnerData.displayName) partnerDisplayName = partnerData.displayName;
                    if (partnerData.level) partnerLevel = partnerData.level;
                    if (partnerData.streak) partnerStreak = partnerData.streak;
                }
            } catch (e) {
                console.log('Using name from match document');
            }

            // Display partner info with real name
            document.getElementById('partnerName').textContent = partnerDisplayName;
            document.getElementById('partnerLevel').textContent = partnerLevel;
            document.getElementById('partnerStreak').textContent = partnerStreak;

            // Signal that this user is ready
            await updateDoc(doc(db, 'matches', matchId), {
                [`ready.${currentUser.uid}`]: true
            });

            // Wait for BOTH users to be ready before starting the session.
            const unsubReady = onSnapshot(doc(db, 'matches', matchId), async (snapshot) => {
                const data = snapshot.data();
                if (data && data.ready && data.ready[foundPartnerId]) {
                    unsubReady();
                    clearTimeout(readyTimeout);
                    statusText.textContent = 'Both connected! Starting session...';
                    // Re-read fresh match data to get latest task/users
                    // (important for replacement matches where data may have changed)
                    const freshSnap = await getDoc(doc(db, 'matches', matchId));
                    const freshMatchData = freshSnap.data();
                    setTimeout(() => startSession(freshMatchData), 2000);
                }
            });

            // Timeout: if partner doesn't join within 30 seconds, expire the match
            // and go back to searching
            const readyTimeout = setTimeout(async () => {
                unsubReady();
                statusText.textContent = 'Partner did not connect. Searching again...';
                try {
                    await updateDoc(doc(db, 'matches', matchId), { status: 'expired' });
                } catch (e) {}
                matchId = null;
                matchHandled = false;
                setTimeout(() => startMatching(), 3000);
            }, 30000);
        }


        async function showMatchFoundState(partnerName, partnerLevel, partnerStreak) {
            console.log('ğŸ‰ Showing match found state'); startMatchFoundTimeout();
            showState('matchFoundState');
            
            // Display partner info
            document.getElementById('partnerName').textContent = partnerName || 'Anonymous Student';
            document.getElementById('partnerLevel').textContent = partnerLevel || 'unknown';
            document.getElementById('partnerStreak').textContent = partnerStreak || '0';
            
            // Wait 3 seconds before starting session
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            console.log('â­ï¸ Transitioning to session...');
        }
        async function startSession(matchData) {
            clearMatchFoundTimeout(); console.log('ğŸ¬ Showing session state'); showState('sessionState');

            // Display task
            const task = matchData.task;
            currentTask = task;
            document.getElementById('taskType').textContent = task.type;
            document.getElementById('taskLevel').textContent = userData.level || 'A1';
            document.getElementById('scenarioGerman').textContent = task.scenario_german;
            document.getElementById('scenarioGujarati').textContent = task.scenario_gujarati;

            const questionsList = document.getElementById('questionsList');
            questionsList.innerHTML = '';
            task.questions.forEach(q => {
                const li = document.createElement('li');
                li.textContent = q;
                questionsList.appendChild(li);
            });

            // Listen for task changes
            onSnapshot(doc(db, 'matches', matchId), (snapshot) => {
                const data = snapshot.data();
                if (data && data.task && data.taskChangedAt) {
                    const newTask = data.task;
                    if (JSON.stringify(newTask) !== JSON.stringify(currentTask)) {
                        currentTask = newTask;
                        displayTask(newTask);
                        showNotification('ğŸ”„ Partner changed task', 'important');
                    }
                }
                
                if (data && data.timeExtended && !timeExtensionUsed) {
                    timeExtensionUsed = true;
                    timeRemaining += 600;
                    sessionDuration += 600;
                    document.getElementById('btnAddTime').disabled = true;
                    document.getElementById('btnAddTime').textContent = 'â° Time Added';
                    showNotification('â° Partner added time', 'important');
                }
            });

            // Start timer
            startTimer();

            // Setup WebRTC FIRST, then monitor (needs peerConnection to exist)
            await setupWebRTC();
            monitorPartnerConnection();
        }

        function startTimer() {
            timeRemaining = sessionDuration;
            timerPaused = false;
            const timerDisplay = document.getElementById('timerDisplay');

            if (sessionTimer) {
                clearInterval(sessionTimer);
            }

            sessionTimer = setInterval(() => {
                if (timerPaused) {
                    return;
                }

                timeRemaining--;
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                timerDisplay.classList.remove('warning', 'danger');
                if (timeRemaining <= 60) {
                    timerDisplay.classList.add('danger');
                } else if (timeRemaining <= 120) {
                    timerDisplay.classList.add('warning');
                }

                if (timeRemaining === 0) {
                    clearInterval(sessionTimer);
                    endSession();
                }
            }, 1000);
        }

        function pauseTimer() {
            timerPaused = true;
        }

        function resumeTimer() {
            timerPaused = false;
        }

        function updateRemoteStatus(state) {
            const dot = document.getElementById('remoteStatusDot');
            const text = document.getElementById('remoteStatusText');
            if (!dot || !text) return;

            if (state === 'connected' || state === 'completed') {
                dot.style.background = '#10b981';
                text.textContent = 'Connected';
            } else if (state === 'checking' || state === 'new') {
                dot.style.background = '#f59e0b';
                text.textContent = 'Connecting...';
            } else if (state === 'disconnected') {
                dot.style.background = '#f59e0b';
                text.textContent = 'Reconnecting...';
            } else if (state === 'failed') {
                dot.style.background = '#ef4444';
                text.textContent = 'Failed';
            } else if (state === 'closed') {
                dot.style.background = '#6b7280';
                text.textContent = 'Closed';
            }
        }


        let lastNotification = '';
        let notificationTimeout = null;
        
        function showNotification(message, type = 'info') {
            // Prevent duplicate notifications
            if (message === lastNotification) return;
            lastNotification = message;
            
            // Clear previous timeout
            if (notificationTimeout) clearTimeout(notificationTimeout);
            
            // Reset after 3 seconds
            notificationTimeout = setTimeout(() => {
                lastNotification = '';
            }, 3000);
            
            // Show alert only if important
            if (type === 'important') {
                alert(message);
            } else {
                console.log('ğŸ“¢', message);
            }
        }

        async function requestMediaWithRetry(maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    console.log(`ğŸ“¹ Requesting camera/mic (attempt ${i + 1})...`);
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user'
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    console.log('âœ… Camera/mic access granted');
                    return stream;
                } catch (error) {
                    console.error(`âŒ Media error (attempt ${i + 1}):`, error);
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        throw new Error('Camera/microphone permission denied. Please allow access in your browser settings and refresh the page.');
                    } else if (error.name === 'NotFoundError') {
                        throw new Error('No camera or microphone found. Please connect a device and try again.');
                    } else if (error.name === 'NotReadableError') {
                        if (i < maxRetries - 1) {
                            console.log('â³ Waiting before retry...');
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            continue;
                        }
                        throw new Error('Camera is being used by another application. Please close other apps and try again.');
                    }
                    
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                }
            }
        }

        // Robust WebRTC connection monitoring
        function setupRobustConnectionMonitoring() {
            if (!peerConnection) return;
            
            let connectionTimeout = null;
            let iceGatheringTimeout = null;
            
            // Monitor ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                console.log('ğŸ”— ICE State:', state);
                updateRemoteStatus(state);
                
                if (state === 'connected' || state === 'completed') {
                    console.log('âœ… WebRTC Connected!');
                    clearTimeout(connectionTimeout);
                    document.getElementById('reconnectingOverlay')?.classList.remove('active');
                    
                    // Clear any replacement flags
                    if (matchId) {
                        updateDoc(doc(db, 'matches', matchId), {
                            isReplacement: false,
                            replacementJoined: false
                        }).catch(e => console.error('Flag clear error:', e));
                    }
                } else if (state === 'disconnected') {
                    console.log('âš ï¸ Partner disconnected');
                    connectionTimeout = setTimeout(() => {
                        console.log('ğŸ”„ Attempting reconnection...');
                        if (peerConnection && peerConnection.iceConnectionState === 'disconnected') {
                            handlePartnerDisconnection();
                        }
                    }, 3000);
                } else if (state === 'failed') {
                    console.log('âŒ Connection failed');
                    handlePartnerDisconnection();
                }
            };
            
            // Monitor overall connection state
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log('ğŸ”— Connection State:', state);
                
                if (state === 'connected') {
                    console.log('âœ… Peer Connected');
                    // Force remote video to play
                    const remoteVideo = document.getElementById('remoteVideo');
                    if (remoteVideo && remoteVideo.srcObject) {
                        remoteVideo.play().catch(e => console.log('Video play error:', e));
                    }
                } else if (state === 'failed' || state === 'closed') {
                    handlePartnerDisconnection();
                }
            };
            
            // Monitor ICE gathering
            peerConnection.onicegatheringstatechange = () => {
                console.log('ğŸ§Š ICE Gathering:', peerConnection.iceGatheringState);
            };
        }
        async function setupWebRTC() {
            try {
                // Get local stream
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: true
                });

                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                localVideo.play().catch(() => {});

                // Create peer connection
                peerConnection = new RTCPeerConnection(rtcConfig);

                // Add local tracks to the connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle remote stream - use event.streams[0] for reliability
                const remoteVideo = document.getElementById('remoteVideo');
                peerConnection.ontrack = (event) => {
                    console.log('ontrack fired:', event.track.kind, 'streams:', event.streams.length);
                    if (event.streams && event.streams[0]) {
                        // Use the stream directly from the event (most reliable)
                        remoteVideo.srcObject = event.streams[0];
                        remoteStream = event.streams[0];
                    } else {
                        // Fallback: create our own MediaStream
                        if (!remoteStream) {
                            remoteStream = new MediaStream();
                            remoteVideo.srcObject = remoteStream;
                        }
                        remoteStream.addTrack(event.track);
                    }
                    // Explicitly play to handle autoplay restrictions on mobile
                    remoteVideo.play().catch(e => {
                        console.log('Remote video autoplay blocked, will retry on interaction:', e);
                        // Add a one-time click handler to start playback
                        document.addEventListener('click', function playOnClick() {
                            remoteVideo.play().catch(() => {});
                            document.removeEventListener('click', playOnClick);
                        }, { once: true });
                    });
                };

                // ICE candidate handling - store as individual docs in a subcollection
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        try {
                            await addDoc(
                                collection(db, 'matches', matchId, 'candidates_' + currentUser.uid),
                                event.candidate.toJSON()
                            );
                        } catch (e) {
                            console.error('Error sending ICE candidate:', e);
                        }
                    }
                };


                // Set connection timeout (30 seconds)
                const connectionTimeout = setTimeout(() => {
                    if (peerConnection && 
                        peerConnection.iceConnectionState !== 'connected' && 
                        peerConnection.iceConnectionState !== 'completed') {
                        console.log('â±ï¸ WebRTC connection timeout');
                        showNotification('Connection timeout. Trying to reconnect...', 'important');
                        handlePartnerDisconnection();
                    }
                }, 30000);
                
                // Clear timeout when connected
                const originalOnIceChange = peerConnection.oniceconnectionstatechange;
                peerConnection.oniceconnectionstatechange = () => {
                    if (originalOnIceChange) originalOnIceChange();
                    if (peerConnection.iceConnectionState === 'connected' || 
                        peerConnection.iceConnectionState === 'completed') {
                        clearTimeout(connectionTimeout);
                    }
                };
                // Setup robust monitoring
                setupRobustConnectionMonitoring();
                
                // DEPRECATED: Old monitoring kept for compatibility
                peerConnection.oniceconnectionstatechange_old = () => {
                    const state = peerConnection.iceConnectionState;
                    console.log('ICE connection state:', state);
                    updateRemoteStatus(state);

                    if (state === 'connected' || state === 'completed') {
                        console.log('WebRTC: ICE connected, remote video should be visible');
                    } else if (state === 'failed') {
                        console.error('WebRTC: ICE failed, attempting restart');
                        peerConnection.restartIce();
                    }
                };

                // Also monitor the overall connection state
                peerConnection.onconnectionstatechange = () => {
                    const state = peerConnection.connectionState;
                    console.log('Connection state:', state);
                    if (state === 'connected') {
                        updateRemoteStatus('connected');
                        // Double-check remote video is playing
                        if (remoteVideo.srcObject) {
                            remoteVideo.play().catch(() => {});
                        }
                    } else if (state === 'failed') {
                        updateRemoteStatus('failed');
                    }
                };

                // Buffer for ICE candidates that arrive before remote description is set.
                // Without buffering, candidates are silently lost and video never connects.
                let iceCandidateBuffer = [];
                let isRemoteDescriptionSet = false;

                async function flushIceCandidateBuffer() {
                    isRemoteDescriptionSet = true;
                    console.log('Flushing', iceCandidateBuffer.length, 'buffered ICE candidates');
                    for (const candidateData of iceCandidateBuffer) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData));
                        } catch (e) {
                            console.error('Error adding buffered ICE candidate:', e);
                        }
                    }
                    iceCandidateBuffer = [];
                }

                // Get match details for signaling
                const matchDocSnap = await getDoc(doc(db, 'matches', matchId));
                const matchData = matchDocSnap.data();
                const users = matchData.users;
                partnerId = users.find(id => id !== currentUser.uid);

                // Update remote video label with partner name
                document.getElementById('remoteLabel').textContent = partnerDisplayName || 'Partner';

                // Listen for remote ICE candidates from partner FIRST
                // so we don't miss any that arrive during offer/answer exchange
                const candidatesRef = collection(db, 'matches', matchId, 'candidates_' + partnerId);
                onSnapshot(query(candidatesRef), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidateData = change.doc.data();
                            if (isRemoteDescriptionSet) {
                                try {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData));
                                } catch (e) {
                                    console.error('Error adding ICE candidate:', e);
                                }
                            } else {
                                iceCandidateBuffer.push(candidateData);
                            }
                        }
                    });
                });

                // Now do the offer/answer exchange
                if (users[0] === currentUser.uid) {
                    // User 1 (offerer): Create and send offer
                    console.log('WebRTC: I am the offerer');
                    const offer = await peerConnection.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: true
                    });
                    await peerConnection.setLocalDescription(offer);
                    await updateDoc(doc(db, 'matches', matchId), {
                        offer: { type: offer.type, sdp: offer.sdp }
                    });

                    // Listen for answer from partner
                    const unsubAnswer = onSnapshot(doc(db, 'matches', matchId), async (snapshot) => {
                        const data = snapshot.data();
                        if (data && data.answer && !peerConnection.remoteDescription) {
                            try {
                                console.log('WebRTC: Received answer, setting remote description');
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                                await flushIceCandidateBuffer();
                                unsubAnswer();
                            } catch (e) {
                                console.error('Error setting remote description (answer):', e);
                            }
                        }
                    });
                } else {
                    // User 2 (answerer): Listen for offer and create answer
                    console.log('WebRTC: I am the answerer');
                    const unsubOffer = onSnapshot(doc(db, 'matches', matchId), async (snapshot) => {
                        const data = snapshot.data();
                        if (data && data.offer && !peerConnection.remoteDescription) {
                            try {
                                console.log('WebRTC: Received offer, setting remote description and creating answer');
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                                const answer = await peerConnection.createAnswer();
                                await peerConnection.setLocalDescription(answer);
                                await updateDoc(doc(db, 'matches', matchId), {
                                    answer: { type: answer.type, sdp: answer.sdp }
                                });
                                await flushIceCandidateBuffer();
                                unsubOffer();
                            } catch (e) {
                                console.error('Error handling offer/creating answer:', e);
                            }
                        }
                    });
                }

            } catch (error) {
                console.error('Error setting up WebRTC:', error);
                alert('Could not access camera/microphone. Please check permissions.');
            }
        }


        // Advanced Features Functions
        window.changeTask = async function() {
            console.log('ğŸ”„ Change Task button clicked!');
            console.log('matchId:', matchId);
            console.log('userData:', userData);
            if (!matchId || !userData) {
                alert('âŒ Not in a session yet!');
                return;
            }
            
            try {
                const newTask = getRandomTask(userData.level || 'A1');
                currentTask = newTask;
                
                await updateDoc(doc(db, 'matches', matchId), {
                    task: newTask,
                    taskChangedAt: serverTimestamp()
                });
                
                displayTask(newTask);
                showNotification('âœ… Task changed: ' + newTask.type, 'important');
            } catch (error) {
                console.error('Error changing task:', error);
                showNotification('âŒ Failed to change task', 'important');
            }
        };

        window.addExtraTime = function() {
            console.log('â° Add Time button clicked!');
            console.log('timeExtensionUsed:', timeExtensionUsed);
            if (timeExtensionUsed) {
                showNotification('â° Time already added', 'important');
                return;
            }
            
            timeRemaining += 600;
            sessionDuration += 600;
            timeExtensionUsed = true;
            
            document.getElementById('btnAddTime').disabled = true;
            document.getElementById('btnAddTime').textContent = 'â° Time Added';
            
            showNotification('âœ… Added 10 minutes!', 'important');
            
            if (matchId) {
                updateDoc(doc(db, 'matches', matchId), {
                    timeExtended: true,
                    extendedAt: serverTimestamp()
                }).catch(console.error);
            }
        };

        function displayTask(task) {
            document.getElementById('taskType').textContent = task.type;
            document.getElementById('scenarioGerman').textContent = task.scenario_german;
            document.getElementById('scenarioGujarati').textContent = task.scenario_gujarati;
            
            const questionsList = document.getElementById('questionsList');
            questionsList.innerHTML = '';
            task.questions.forEach(q => {
                const li = document.createElement('li');
                li.textContent = q;
                questionsList.appendChild(li);
            });
        }

        function monitorPartnerConnection() {
            if (!peerConnection) return;
            
            peerConnection.oniceconnectionstatechange = async () => {
                const state = peerConnection.iceConnectionState;
                console.log('ICE state:', state);
                
                if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                    console.log('Partner disconnected!');
                    await handlePartnerDisconnection();
                }
            };
        }

        async function handlePartnerDisconnection() {
            try {
                pauseTimer();
                
                document.getElementById('reconnectingOverlay').classList.add('active');
                document.getElementById('reconnectingMessage').textContent = 'Finding new partner...';
                
                // Close old WebRTC connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    remoteStream = null;
                    document.getElementById('remoteVideo').srcObject = null;
                }
                
                // Mark the disconnected partner and clean up their queue entry
                // so they don't appear as "waiting" to anyone else
                const disconnectedPartnerId = partnerId;
                
                await updateDoc(doc(db, 'matches', matchId), {
                    [`disconnected.${disconnectedPartnerId}`]: true,
                    lookingForReplacement: true
                });
                
                // Try to remove disconnected partner from queue 
                // (their beforeunload may not have fired)
                try {
                    await deleteDoc(doc(db, 'match_queue', disconnectedPartnerId));
                    console.log('ğŸ§¹ Removed disconnected partner from queue');
                } catch (e) {
                    console.log('Could not remove partner from queue (may be security rules)');
                }
                
                await findReplacementPartner();
                
            } catch (error) {
                console.error('Error:', error);
                setTimeout(() => {
                    document.getElementById('reconnectingOverlay').classList.remove('active');
                    endSession();
                }, 2000);
            }
        }


        let replacementAttempts = 0;
        const MAX_REPLACEMENT_ATTEMPTS = 12; // 12 attempts Ã— 5 seconds = 60 seconds max

        // Listen for replacement being fulfilled
        function listenForReplacement() {
            if (!matchId) return;
            
            const matchRef = doc(db, 'matches', matchId);
            const unsubscribe = onSnapshot(matchRef, async (snapshot) => {
                const data = snapshot.data();
                if (!data) return;
                
                // Check if replacement was completed
                if (data.replacementComplete && data.users && data.users.length === 2) {
                    const newPartnerId = data.users.find(id => id !== currentUser.uid);
                    
                    if (newPartnerId !== partnerId) {
                        console.log('âœ… Replacement partner joined!');
                        partnerId = newPartnerId;
                        
                        // Close reconnecting overlay
                        const overlay = document.getElementById('reconnectingOverlay');
                        if (overlay) overlay.classList.remove('active');
                        
                        // Setup new WebRTC connection
                        await setupWebRTC();
                        
                        // Resume timer
                        if (typeof resumeTimer === 'function') resumeTimer();
                        
                        showNotification('âœ… New partner connected!', 'important');
                        
                        // Stop listening
                        unsubscribe();
                    }
                }
            });
        }
        async function findReplacementPartner() {
            try {
                const queueRef = collection(db, 'match_queue');
                const q = query(
                    queueRef,
                    where('status', '==', 'waiting')
                );
                
                const snapshot = await getDocs(q);
                const candidates = [];
                const now = Date.now();
                const STALE_THRESHOLD = 30000; // 30 seconds â€” must match heartbeat
                
                snapshot.forEach(docSnap => {
                    // Don't match with yourself OR the disconnected partner
                    if (docSnap.id !== currentUser.uid && docSnap.id !== partnerId) {
                        const data = docSnap.data();
                        const lastSeen = data.lastSeen?.toMillis() || data.timestamp?.toMillis() || 0;
                        const age = now - lastSeen;
                        
                        // Only include fresh entries (heartbeat within threshold)
                        if (age < STALE_THRESHOLD) {
                            candidates.push({ id: docSnap.id, ...data, age });
                        } else {
                            console.log(`ğŸ—‘ï¸ Skipping stale candidate: ${docSnap.id} (${Math.floor(age/1000)}s old)`);
                            deleteDoc(docSnap.ref).catch(e => {});
                        }
                    }
                });
                
                if (candidates.length > 0) {
                    // Sort by freshness
                    candidates.sort((a, b) => a.age - b.age);
                    const newPartner = candidates[0];
                    
                    // Verify partner is actually online
                    const isOnline = await verifyPartnerOnline(newPartner.id);
                    if (!isOnline) {
                        console.log('âš ï¸ Replacement candidate was stale, retrying...');
                        setTimeout(() => {
                            if (document.getElementById('reconnectingOverlay').classList.contains('active')) {
                                findReplacementPartner();
                            }
                        }, 3000);
                        return;
                    }
                    
                    const oldPartnerId = partnerId;
                    partnerId = newPartner.id;
                    
                    // CRITICAL: Clear ALL stale WebRTC signaling data from the match doc.
                    // Without this, the new partner picks up the old offer/answer and
                    // the WebRTC connection silently fails because SDP doesn't match.
                    // Also clear old ready flags so the new handshake works properly.
                    
                    // First, delete old ICE candidate subcollections
                    try {
                        const oldCandidatesRef = collection(db, 'matches', matchId, 'candidates_' + oldPartnerId);
                        const oldCandidates = await getDocs(oldCandidatesRef);
                        const deletions = [];
                        oldCandidates.forEach(d => deletions.push(deleteDoc(d.ref)));
                        await Promise.all(deletions);
                        
                        const myCandidatesRef = collection(db, 'matches', matchId, 'candidates_' + currentUser.uid);
                        const myCandidates = await getDocs(myCandidatesRef);
                        const myDeletions = [];
                        myCandidates.forEach(d => myDeletions.push(deleteDoc(d.ref)));
                        await Promise.all(myDeletions);
                    } catch (e) {
                        console.log('ICE candidate cleanup:', e);
                    }
                    
                    // Update match doc: new users, clear signaling, clear ready flags
                    await updateDoc(doc(db, 'matches', matchId), {
                        users: [currentUser.uid, partnerId],
                        userNames: {
                            [currentUser.uid]: getUserDisplayName(),
                            [partnerId]: newPartner.displayName || 'Student'
                        },
                        // Clear stale WebRTC signaling
                        offer: null,
                        answer: null,
                        // Clear ready flags so handleMatchFound works for new partner
                        ready: { [currentUser.uid]: true },
                        // Clear disconnection flags
                        disconnected: {},
                        lookingForReplacement: false,
                        replacementAt: serverTimestamp()
                    });
                    
                    // Update new partner's queue entry so their listener picks it up
                    try {
                        await updateDoc(doc(db, 'match_queue', partnerId), {
                            matchId: matchId,
                            status: 'matched'
                        });
                    } catch (e) {
                        console.log('Partner will detect match via matches listener');
                    }
                    
                    // DON'T call setupWebRTC here! Wait for the new partner to go
                    // through handleMatchFound, set their ready flag, and THEN both
                    // sides set up WebRTC through the normal startSession flow.
                    // Device B (us) will detect partner's ready flag and proceed.
                    
                    // Listen for new partner's ready signal
                    const unsubReady = onSnapshot(doc(db, 'matches', matchId), async (snap) => {
                        const data = snap.data();
                        if (data && data.ready && data.ready[partnerId]) {
                            unsubReady();
                            clearTimeout(replacementReadyTimeout);
                            console.log('âœ… Replacement partner is ready, starting WebRTC');
                            
                            // Now both are ready â€” set up WebRTC
                            await setupWebRTC();
                            
                            resumeTimer();
                            document.getElementById('reconnectingOverlay').classList.remove('active');
                            showNotification('âœ… New partner joined!', 'important');
                        }
                    });
                    
                    // Timeout if new partner doesn't respond
                    const replacementReadyTimeout = setTimeout(() => {
                        unsubReady();
                        console.log('â±ï¸ Replacement partner did not respond');
                        // Try finding another partner
                        findReplacementPartner();
                    }, 20000);
                    
                } else {
                    document.getElementById('reconnectingMessage').textContent = 'Waiting for partners...';
                    setTimeout(() => {
                        if (document.getElementById('reconnectingOverlay').classList.contains('active')) {
                            findReplacementPartner();
                        }
                    }, 3000);
                }
                
            } catch (error) {
                console.error('Error finding replacement:', error);
                setTimeout(() => {
                    if (document.getElementById('reconnectingOverlay').classList.contains('active')) {
                        findReplacementPartner();
                    }
                }, 3000);
            }
        }

                window.toggleAudio = function() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                const btn = document.getElementById('toggleAudio');
                btn.textContent = audioTrack.enabled ? 'ğŸ¤ Mute' : 'ğŸ”‡ Unmute';
            }
        };

        window.toggleVideo = function() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                const btn = document.getElementById('toggleVideo');
                btn.textContent = videoTrack.enabled ? 'ğŸ“¹ Stop Video' : 'ğŸ“¹ Start Video';
            }
        };

        window.endSession = function() {
            // Stop timer
            if (sessionTimer) {
                clearInterval(sessionTimer);
            }
            
            // Stop heartbeat
            stopQueueHeartbeat();

            // Stop streams
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Mark match as completed so it won't be picked up as a stale match
            if (matchId) {
                updateDoc(doc(db, 'matches', matchId), { status: 'completed' }).catch(() => {});
            }
            
            // Remove from queue so we don't appear as available
            if (currentUser) {
                deleteDoc(doc(db, 'match_queue', currentUser.uid)).catch(() => {});
            }

            // Show evaluation
            showState('evaluationState');
            setupEvaluationListeners();
        };

        function setupEvaluationListeners() {
            document.querySelectorAll('.rating-buttons').forEach(container => {
                const criteria = container.dataset.criteria;
                container.querySelectorAll('.rating-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove selected from siblings
                        container.querySelectorAll('.rating-btn').forEach(b => b.classList.remove('selected'));
                        // Add selected to clicked
                        btn.classList.add('selected');
                        // Store value
                        evaluationScores[criteria] = parseInt(btn.dataset.value);
                        // Check if all criteria rated
                        checkEvaluationComplete();
                    });
                });
            });
        }

        function checkEvaluationComplete() {
            const allRated = Object.values(evaluationScores).every(score => score > 0);
            document.getElementById('submitEvaluation').disabled = !allRated;
        }

        window.submitEvaluation = async function() {
            // Save evaluation to Firestore and mark match as completed
            await updateDoc(doc(db, 'matches', matchId), {
                [`evaluations.${currentUser.uid}`]: evaluationScores,
                [`completed.${currentUser.uid}`]: true,
                status: 'completed'
            });

            // Award points
            const pointsEarned = 50;
            await updateDoc(doc(db, 'users', currentUser.uid), {
                totalScore: (userData.totalScore || 0) + pointsEarned,
                weeklyScore: (userData.weeklyScore || 0) + pointsEarned,
                sessionsCompleted: (userData.sessionsCompleted || 0) + 1
            });

            // Clean up
            await deleteDoc(doc(db, 'match_queue', currentUser.uid));

            // Show results (simulate partner's evaluation)
            document.getElementById('resultFluency').textContent = Math.floor(Math.random() * 2) + 4;
            document.getElementById('resultVocabulary').textContent = Math.floor(Math.random() * 2) + 3;
            document.getElementById('resultGrammar').textContent = Math.floor(Math.random() * 2) + 3;
            document.getElementById('resultTaskCompletion').textContent = Math.floor(Math.random() * 2) + 4;

            showState('resultsState');
        };

        window.cancelMatching = async function() {
            // Clean up match if one was created
            if (matchId) {
                try {
                    await updateDoc(doc(db, 'matches', matchId), { status: 'cancelled' });
                } catch (e) {}
            }
            await deleteDoc(doc(db, 'match_queue', currentUser.uid));
            window.location.href = 'dashboard.html';
        };

        window.practiceAgain = function() {
            // Reset everything
            evaluationScores = { fluency: 0, vocabulary: 0, grammar: 0, taskCompletion: 0 };
            matchId = null;
            matchHandled = false;
            partnerDisplayName = 'Partner';
            location.reload();
        };

        window.backToDashboard = function() {
            window.location.href = 'dashboard.html';
        };

        // Clean up queue entry and connections when leaving the page
        // IMPORTANT: beforeunload CANNOT reliably do async Firestore writes.
        // The browser kills the page before they complete. Instead we use
        // synchronous cleanup + mark dirty so the NEXT load cleans up.
        window.addEventListener('beforeunload', () => {
            console.log('ğŸ§¹ Cleaning up on page unload...');
            
            // Stop all streams immediately (synchronous)
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
            
            // Mark in sessionStorage that we need cleanup on next load
            // (since async Firestore writes in beforeunload are unreliable)
            if (currentUser) {
                try {
                    sessionStorage.setItem('sprechen_dirty_uid', currentUser.uid);
                    if (matchId) {
                        sessionStorage.setItem('sprechen_dirty_match', matchId);
                    }
                } catch (e) {}
            }

            // Fire-and-forget: these MAY or MAY NOT complete
            if (currentUser) {
                deleteDoc(doc(db, 'match_queue', currentUser.uid)).catch(() => {});
                if (matchId) {
                    updateDoc(doc(db, 'matches', matchId), {
                        [`disconnected.${currentUser.uid}`]: true,
                        needsReplacement: true,
                        status: 'completed'
                    }).catch(() => {});
                }
            }
        });

        // Also use pagehide (more reliable on mobile than beforeunload)
        window.addEventListener('pagehide', () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
        });

        // DO NOT mark disconnection on visibilitychange â€” switching tabs
        // is normal behavior and shouldn't disconnect the session.
        // Only track extended absence (> 60 seconds hidden).
        let hiddenTimestamp = null;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                hiddenTimestamp = Date.now();
            } else if (hiddenTimestamp && currentUser && matchId) {
                const hiddenDuration = Date.now() - hiddenTimestamp;
                hiddenTimestamp = null;
                // Only mark disconnected if tab was hidden for > 60 seconds
                if (hiddenDuration > 60000) {
                    updateDoc(doc(db, 'matches', matchId), {
                        [`disconnected.${currentUser.uid}`]: true
                    }).catch(() => {});
                }
            }
        });

        // Debug: Check if functions are properly registered
        console.log('ğŸ” Sprechen Buddy Loaded - Function Check:');
        console.log('  âœ“ changeTask:', typeof window.changeTask);
        console.log('  âœ“ addExtraTime:', typeof window.addExtraTime);
        console.log('  âœ“ toggleAudio:', typeof window.toggleAudio);
        console.log('  âœ“ toggleVideo:', typeof window.toggleVideo);
        console.log('  âœ“ endSession:', typeof window.endSession);
    </script>
</body>
</html>
